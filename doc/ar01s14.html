<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>The available rich booleans</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.70.1"><link rel="start" href="index.html" title="Rich booleans, version 2.2.2"><link rel="up" href="index.html" title="Rich booleans, version 2.2.2"><link rel="prev" href="ar01s13.html" title="Known problems"><link rel="next" href="ar01s15.html" title="Using Rich Boolean functors in Rich Boolean macros"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">The available rich booleans</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s13.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s15.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id505135"></a>The available rich booleans</h2></div></div></div><a class="indexterm" name="id505141"></a><p>All the classes mentioned in this section are in the namespace RichBool,
    which is omitted in the text for brevity.</p><p>Note: Many Rich Booleans have two versions, one that starts with <code class="code">rb</code> followed by uppercase
	letters or digits, and another that starts with <code class="code">rbv</code> followed by uppercase letters or digits.
	The Rich Booleans of the first kind are meant for assertion
	macros that don't return a value, the Rich Booleans of the second kind are meant for assertion
	macros that do return a value. The difference has to do with implementation issues.
	An assertion macro that returns a value will usually
	return the first argument of the Rich Boolean, but there are some exceptions,
	which are mentionned in the documentation of the Rich Booleans in question below.</p><p>If you use Visual C++ 6 and use a literal string in a Rich Boolean that returns a value,
	you should cast it to <code class="code">const char*</code>, due to a limitation of this compiler.
	</p><pre class="programlisting">// does not work with Visual C++ 6:
const char *name = MOD_VERIFY_V(rbvFILE_EXISTS("file.txt"));
	
// ok:
const char *name = MOD_VERIFY_V(rbvFILE_EXISTS((const char*)"file.txt"));
	</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id505170"></a>Comparing values</h3></div></div></div><a class="indexterm" name="id505172"></a><a class="indexterm" name="id505180"></a><p>To use the Rich Booleans in this section, include <code class="filename">richbool/richbool.hpp</code>
        Note: the parameters of these Rich Booleans can have different types, as long as the
        required operators and function are overloaded for them. E.g. for <code class="code">rbEQUAL(a,b)</code>
        you can give a <code class="classname">std::string</code> object and a character literal, because
        <code class="code">operator==</code> is defined on these.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id505206"></a>
				<code class="code">rbEQUAL(a,b), rbvEQUAL(a,b)</code>
			</h4></div></div></div><a class="indexterm" name="id505208"></a><p>This macro checks whether its arguments are equal (with <code class="code">operator==</code>). Upon
        failure, it converts its arguments to strings, which will be shown in the output.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;1&gt; == `b':&lt;2&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">Equal&lt;class GetValue1=Value, class GetValue2=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id505252"></a>
				<code class="code">rbEQUAL_PTR(a,b), rbvEQUAL_PTR(a,b)</code>
			</h4></div></div></div><a class="indexterm" name="id505254"></a><p>This macro checks whether its arguments, which should be pointers, are equal
        (with <code class="code">operator==</code>). Upon
        failure, it converts its arguments to strings, and if they are considered valid pointers, the values that
        they point to will also be converted to a string, which will all be shown in the output.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">(0x0012feb0 -&gt; 1) == (0x0012feac -&gt; 1) - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">(0x0012feb0 -&gt; 1) == (0x00000000) - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">EqualPtr&lt;class GetValue1=Value, class GetValue2=Value &gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id505307"></a>
				<code class="code">rbLESS(a,b), rbvLESS(a,b)</code>
			</h4></div></div></div><a class="indexterm" name="id505309"></a><p>This macro checks whether <code class="code">a</code> is less than <code class="code">b</code> (with <code class="code">operator&lt;</code>). Upon
        failure, it converts its arguments to strings, which will be shown in the output.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;3&gt; &lt; `b':&lt;2&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">Less&lt;class GetValue1=Value, class GetValue2=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id505358"></a>
				<code class="code">rbLESS_OR_EQUAL(a,b), rbvLESS_OR_EQUAL(a,b)</code>
			</h4></div></div></div><a class="indexterm" name="id505361"></a><p>This macro checks whether <code class="code">a</code> is less than or equal to <code class="code">b</code> (with <code class="code">operator&lt;=</code>). Upon
        failure, it converts its arguments to strings, which will be shown in the output.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;3&gt; &lt;= `b':&lt;2&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">LessOrEqual&lt;class GetValue1=Value, class GetValue2=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id505410"></a>
				<code class="code">rbMORE(a,b), rbvMORE(a,b)</code>
			</h4></div></div></div><a class="indexterm" name="id505412"></a><p>This macro checks whether <code class="code">a</code> is bigger than <code class="code">b</code> (with <code class="code">operator&gt;</code>). Upon
        failure, it converts its arguments to strings, which will be shown in the output.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;2&gt; &gt; `b':&lt;3&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">More&lt;class GetValue1=Value, class GetValue2=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id505462"></a>
				<code class="code">rbMORE_OR_EQUAL(a,b), rbvMORE_OR_EQUAL(a,b)</code>
			</h4></div></div></div><a class="indexterm" name="id505464"></a><p>This macro checks whether <code class="code">a</code> is more than or equal to <code class="code">b</code> (with <code class="code">operator&gt;=</code>). Upon
        failure, it converts its arguments to strings, which will be shown in the output.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;2&gt; &gt;= `b':&lt;3&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">MoreOrEqual&lt;class GetValue1=Value, class GetValue2=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id505513"></a>
				<code class="code">rbDIFF(a,b), rbvDIFF(a,b)</code>
			</h4></div></div></div><a class="indexterm" name="id505516"></a><p>This macro checks whether its arguments are different (with <code class="code">operator!=</code>). Upon
        failure, it converts its arguments to strings, which will be shown in the output.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;2&gt; != `b':&lt;2&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">Diff&lt;class GetValue1=Value, class GetValue2=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id505559"></a>
				<code class="code">rbEQUAL_USING_LESS(a,b), rbvEQUAL_USING_LESS(a,b)</code>
			</h4></div></div></div><a class="indexterm" name="id505561"></a><p>This macro checks whether its arguments are equal, but using <code class="code">operator&lt;</code>
			instead of <code class="code">operator==</code> (i.e. by evaluating <code class="code">!(a&lt;b) &amp;&amp; !(b&lt;a)</code>).
			Upon failure, it converts its arguments to strings, which will be shown in the output.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;1&gt; == `b':&lt;2&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">EqualUsingLess&lt;class GetValue1=Value, class GetValue2=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id505612"></a>
				<code class="code">rbEQUAL_USING_MORE(a,b), rbvEQUAL_USING_MORE(a,b)</code>
			</h4></div></div></div><a class="indexterm" name="id505614"></a><p>This macro checks whether its arguments are equal, but using <code class="code">operator&gt;</code>
			instead of <code class="code">operator==</code> (i.e. by evaluating <code class="code">!(a&gt;b) &amp;&amp; !(b&gt;a)</code>).
			Upon failure, it converts its arguments to strings, which will be shown in the output.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;1&gt; == `b':&lt;2&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">EqualUsingMore&lt;class GetValue1=Value, class GetValue2=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id505664"></a>
				<code class="code">rbIN_INTERVAL(val, low, high), rbvIN_INTERVAL(val, low, high)</code>
			</h4></div></div></div><a class="indexterm" name="id505667"></a><p>This macro checks whether <code class="code">val</code> is in the closed interval <code class="code">low</code> and <code class="code">high</code>.
        It only uses <code class="code">operator&lt;</code> on the arguments. Upon
        failure, it converts its arguments to strings, which will be shown with the message that <code class="code">val</code> was
        not in the interval of <code class="code">low</code> and <code class="code">high</code>.</p><p>It is recommended to use the Rich Boolean <code class="code">rbORDER3</code> instead, which is more flexible, unless
			the concept of an interval (or range) is important in your code and you want to express that by using this Rich Boolean.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`val':&lt;6&gt; in [`low':&lt;2&gt;, `high':&lt;4&gt;] - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">InInterval&lt;class GetValue1=Value, class GetValue2=Value, class GetValue3=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id505739"></a>
				<code class="code">rbIN_OPEN_INTERVAL(val, low, high), rbvIN_OPEN_INTERVAL(val, low, high)</code>
			</h4></div></div></div><a class="indexterm" name="id505741"></a><p>This macro checks whether <code class="code">val</code> is in the open interval (<code class="code">low</code>, <code class="code">high</code>).
        It only uses <code class="code">operator&lt;</code> on the arguments. Upon
        failure, it converts its arguments to strings, which will be shown with the message that <code class="code">val</code> was
        not in the open interval of <code class="code">low</code> and <code class="code">high</code>.</p><p>It is recommended to use the Rich Boolean <code class="code">rbORDER3</code> instead, which is more flexible, unless
			the concept of an interval (or range) is important in your code and you want to express that by using this Rich Boolean.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`val':&lt;4&gt; in (`low':&lt;2&gt;, `high':&lt;4&gt;) - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">InInterval&lt;class GetValue1=Value, class GetValue2=Value, class GetValue3=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id505812"></a>
				<code class="code">rbORDER2(a, op, b), rbvORDER2(a, op, b)</code>
			</h4></div></div></div><a class="indexterm" name="id505814"></a><p>This macro checks whether its arguments <code class="code">a</code> and <code class="code">b</code> satisfy the relation
			<code class="code">op</code>. <code class="code">op</code> can be <code class="code">==</code>, <code class="code">&lt;</code>, <code class="code">&lt;=</code>, <code class="code">&gt;</code>,
			<code class="code">&gt;=</code> or <code class="code">!=</code>. Upon failure, it converts its arguments to strings, which will be shown in the output.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;2&gt; &lt; `b':&lt;1&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">Order2&lt;class Relation, class GetValue1=Value, class GetValue2=Value, class Stringize=MakeString&gt;</code>
				<code class="classname">Relation</code> can be any of <code class="classname">EqualRelation</code>,
			    <code class="classname">LessRelation</code>, <code class="classname">LessOrEqualRelation</code>,
			    <code class="classname">MoreRelation</code>, <code class="classname">MoreOrEqualRelation</code> and
			    <code class="classname">DifferentRelation</code>.
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id505914"></a>
				<code class="code">rbORDER3(a, op1, b, op2, c), rbvORDER3(a, op1, b, op2, c)</code>
			</h4></div></div></div><a class="indexterm" name="id505916"></a><p>This macro checks whether its arguments <code class="code">a</code>, <code class="code">b</code> and <code class="code">c</code> satisfy the relations
			<code class="code">a op1 b</code> and <code class="code">b op2 c</code>. <code class="code">op1</code> and <code class="code">op2</code> can be <code class="code">==</code>,
			<code class="code">&lt;</code>, <code class="code">&lt;=</code>, <code class="code">&gt;</code>,
			<code class="code">&gt;=</code> or <code class="code">!=</code>. Upon failure, it converts its arguments to strings, which will be shown in the output.</p><p>Note: Assertion macros that return a value, and have <code class="code">rbvORDER3</code> as the condition, will
			return the third argument (i.e. the second value), not the first value.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;2&gt; &lt; `b':&lt;1&gt; &lt; `c':&lt;3&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">Order3&lt;class Relation1, class Relation2, class GetValue1=Value, class GetValue2=Value,
				class GetValue3=Value, class Stringize=MakeString&gt;</code>
				<code class="classname">Relation1</code> and <code class="classname">Relation2</code> can be any of <code class="classname">EqualRelation</code>,
			    <code class="classname">LessRelation</code>, <code class="classname">LessOrEqualRelation</code>,
			    <code class="classname">MoreRelation</code>, <code class="classname">MoreOrEqualRelation</code> and
			    <code class="classname">DifferentRelation</code>.
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id506039"></a>
				<code class="code">rbORDER4(a, op1, b, op2, c, op3, d)</code>
			</h4></div></div></div><a class="indexterm" name="id506041"></a><p>This macro checks whether its arguments <code class="code">a</code>, <code class="code">b</code>, <code class="code">c</code>
			and <code class="code">d</code> satisfy the relations <code class="code">a op1 b</code>, <code class="code">b op2 c</code> and
			<code class="code">c op3 d</code>. <code class="code">op1</code>, <code class="code">op2</code> and <code class="code">op3</code> can be <code class="code">==</code>,
			<code class="code">&lt;</code>, <code class="code">&lt;=</code>, <code class="code">&gt;</code>,
			<code class="code">&gt;=</code> or <code class="code">!=</code>. Upon failure, it converts its arguments to strings, which will be shown in the output.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;1&gt; &lt; `b':&lt;2&gt; &lt;= `c':&lt;2&gt; &lt; `d':&lt;0&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">Order4&lt;class Relation1, class Relation2, class Relation3, class GetValue1=Value, 
				class GetValue2=Value, class GetValue3=Value, class GetValue4=Value, class Stringize=MakeString&gt;</code>
				<code class="classname">Relation1</code>, <code class="classname">Relation2</code> and <code class="classname">Relation3</code>
				can be any of <code class="classname">EqualRelation</code>,
			    <code class="classname">LessRelation</code>, <code class="classname">LessOrEqualRelation</code>,
			    <code class="classname">MoreRelation</code>, <code class="classname">MoreOrEqualRelation</code> and
			    <code class="classname">DifferentRelation</code>.
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id506170"></a>
				<code class="code">rbNEAR(a,b,diff), rbvNEAR(a,b,diff)</code>
			</h4></div></div></div><a class="indexterm" name="id506172"></a><p>This macro checks whether its two first arguments are close enough,
			i.e. if their difference isn't more than the third argument. Upon
        failure, it converts its arguments to strings, which will be shown in the output.
        The actual difference is also shown.
        This can only be used with floating point numbers, and objects
        on which <code class="code">operator-</code> is defined and for which the function <code class="code">fabs</code> is overloaded.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">fabs(`a':&lt;1.0&gt;-`b':&lt;2.0&gt;) = 1 &lt;= `diff':&lt;0.1&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">Near&lt;class GetValue1=Value, class GetValue2=Value, class GetValue3=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id506218"></a>
				<code class="code">rbLESS_NEAR(a,b,diff), rbvLESS_NEAR(a,b,diff)</code>
			</h4></div></div></div><a class="indexterm" name="id506220"></a><p>This macro checks whether first argument is less than the second,
			 but allowing a tolerance of <code class="code">diff</code>, i.e. if the first is between <code class="code">b</code>
			 and <code class="code">b+diff</code>, it is still accepted. Upon
        failure, it converts its arguments to strings, which will be shown in the output.
        The actual difference is also shown.
        This can only be used with floating point numbers, and objects
        on which <code class="code">operator-</code> is defined and for which the function <code class="code">fabs</code> is overloaded.</p><p>Note that this is <span class="emphasis"><em>less</em></span> strict than <code class="code">rbLESS</code>.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;1.0&gt; &lt;~`b':&lt;2.0&gt; (difference is &lt;1&gt;, `diff':&lt;0.1&gt; allowed) - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">LessNear&lt;class GetValue1=Value, class GetValue2=Value, class GetValue3=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id506287"></a>
				<code class="code">rbMORE_NEAR(a,b,diff), rbvMORE_NEAR(a,b,diff)</code>
			</h4></div></div></div><a class="indexterm" name="id506290"></a><p>This macro checks whether the first argument is more than the second,
			 but allowing a tolerance of <code class="code">diff</code>, i.e. if the first is between <code class="code">b</code>
			 and <code class="code">b-diff</code>, it is still accepted. Upon
        failure, it converts its arguments to strings, which will be shown in the output.
        The actual difference is also shown.
        This can only be used with floating point numbers, and objects
        on which <code class="code">operator-</code> is defined and for which the function <code class="code">fabs</code> is overloaded.</p><p>Note that this is <span class="emphasis"><em>less</em></span> strict than <code class="code">rbMORE</code>.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;1.0&gt; &gt;~`b':&lt;2.0&gt; (difference is &lt;1&gt;, `diff':&lt;0.1&gt; allowed) - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">MoreNear&lt;class GetValue1=Value, class GetValue2=Value, class GetValue3=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id506357"></a>
				<code class="code">rbDIFF_NEAR(a,b,diff), rbvIFF_NEAR(a,b,diff)</code>
			</h4></div></div></div><a class="indexterm" name="id506359"></a><p>This macro checks whether the first argument is different from the second,
			 requiring a tolerance of <code class="code">diff</code>, i.e. if the first is between <code class="code">b-diff</code>
			 and <code class="code">b+diff</code>, it is neither accepted. Upon
        failure, it converts its arguments to strings, which will be shown in the output.
        The actual difference is also shown.
        This can only be used with floating point numbers, and objects
        on which <code class="code">operator-</code> is defined and for which the function <code class="code">fabs</code> is overloaded.</p><p>Note that this is <span class="emphasis"><em>more</em></span> strict than <code class="code">rbDIFF</code>.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;1.0&gt; &gt;~`b':&lt;2.0&gt; (difference is &lt;1&gt;, `diff':&lt;0.1&gt; allowed) - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">MoreNear&lt;class GetValue1=Value, class GetValue2=Value, class GetValue3=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id506426"></a>
				<code class="code">rbIN_INTERVAL_NEAR(val, low, high, diff), rbvIN_INTERVAL_NEAR(val, low, high, diff)</code>
			</h4></div></div></div><a class="indexterm" name="id506429"></a><p>This macro checks whether <code class="code">val</code> is in the closed interval <code class="code">low</code> and <code class="code">high</code>.
        It only uses <code class="code">operator&lt;</code> on the arguments. Upon
        failure, it converts its arguments to strings, which will be shown with the message that <code class="code">val</code> was
        not in the interval of <code class="code">low</code> and <code class="code">high</code>.</p><p>It is recommended to use the Rich Boolean <code class="code">rbORDER3</code> instead, which is more flexible, unless
			the concept of an interval (or range) is important in your code and you want to express that by using this Rich Boolean.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`val':&lt;6&gt; in [`low':&lt;2&gt;, `high':&lt;4&gt;] - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">InIntervalNear&lt;class GetValue1=Value, class GetValue2=Value, class GetValue3=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id506500"></a>
				<code class="code">rbORDER2_NEAR(a, op, b, diff), rbvORDER2_NEAR(a, op, b, diff)</code>
			</h4></div></div></div><a class="indexterm" name="id506502"></a><p>This macro checks whether its arguments <code class="code">a</code> and <code class="code">b</code> satisfy the relation
			<code class="code">op</code>, allowing a tolerance of <code class="code">diff</code>.
			<code class="code">op</code> can be <code class="code">==</code>, <code class="code">&lt;</code>, <code class="code">&lt;=</code>, <code class="code">&gt;</code>,
			<code class="code">&gt;=</code> or <code class="code">!=</code>. Upon failure, it converts its arguments to strings, which will be shown in the output.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;2&gt; &lt;~ `b':&lt;1&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">Order2Near&lt;class Relation, class GetValue1=Value, class GetValue2=Value, class Stringize=MakeString&gt;</code>
				<code class="classname">Relation</code> can be any of <code class="classname">EqualNearRelation</code>,
			    <code class="classname">LessNearRelation</code>,
			    <code class="classname">MoreNearRelation</code> and
			    <code class="classname">DifferentNearRelation</code>.
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id506599"></a>
				<code class="code">rbORDER3_NEAR(a, op1, b, op2, c, diff), rbvORDER3_NEAR(a, op1, b, op2, c, diff)</code>
			</h4></div></div></div><a class="indexterm" name="id506602"></a><p>This macro checks whether its arguments <code class="code">a</code>, <code class="code">b</code> and <code class="code">c</code> satisfy the relations
			<code class="code">a op1 b</code> and <code class="code">b op2 c</code>, allowing a tolerance of <code class="code">diff</code>.
			<code class="code">op1</code> and <code class="code">op2</code> can be <code class="code">==</code>,
			<code class="code">&lt;</code>, <code class="code">&lt;=</code>, <code class="code">&gt;</code>,
			<code class="code">&gt;=</code> or <code class="code">!=</code>. Upon failure, it converts its arguments to strings, which will be shown in the output.</p><p>Note: Assertion macros that return a value, and have <code class="code">rbvORDER3</code> as the condition, will
			return the third argument (i.e. the second value), not the first value.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;2&gt; &lt; `b':&lt;1&gt; &lt; `c':&lt;3&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">Order3Near&lt;class Relation1, class Relation2, class GetValue1=Value, class GetValue2=Value,
				class GetValue3=Value, class Stringize=MakeString&gt;</code>
				<code class="classname">Relation1</code> and <code class="classname">Relation2</code> can be any of <code class="classname">EqualNearRelation</code>,
			    <code class="classname">LessNearRelation</code>,
			    <code class="classname">MoreNearRelation</code>, and
			    <code class="classname">DifferentNearRelation</code>.
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id506719"></a>
				<code class="code">rbORDER4_NEAR(a, op1, b, op2, c, op3, d, diff)</code>
			</h4></div></div></div><a class="indexterm" name="id506722"></a><p>This macro checks whether its arguments <code class="code">a</code>, <code class="code">b</code>, <code class="code">c</code>
			and <code class="code">d</code> satisfy the relations <code class="code">a op1 b</code>, <code class="code">b op2 c</code> and
			<code class="code">c op3 d</code>. <code class="code">op1</code>, <code class="code">op2</code> and <code class="code">op3</code> can be <code class="code">==</code>,
			<code class="code">&lt;</code>, <code class="code">&lt;=</code>, <code class="code">&gt;</code>,
			<code class="code">&gt;=</code> or <code class="code">!=</code>. Upon failure, it converts its arguments to strings, which will be shown in the output.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;1&gt; &lt; `b':&lt;2&gt; &lt;= `c':&lt;2&gt; &lt; `d':&lt;0&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">Order4&lt;class Relation1, class Relation2, class Relation3, class GetValue1=Value, 
				class GetValue2=Value, class GetValue3=Value, class GetValue4=Value, class Stringize=MakeString&gt;</code>
				<code class="classname">Relation1</code>, <code class="classname">Relation2</code> and <code class="classname">Relation3</code>
				can be any of <code class="classname">EqualRelation</code>,
			    <code class="classname">LessRelation</code>, <code class="classname">LessOrEqualRelation</code>,
			    <code class="classname">MoreRelation</code>, <code class="classname">MoreOrEqualRelation</code> and
			    <code class="classname">DifferentRelation</code>.
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id506850"></a>
				<code class="code">rbREL_NEAR(a,b,diff), rbvREL_NEAR(a,b,diff)</code>
			</h4></div></div></div><a class="indexterm" name="id506852"></a><p>This macro checks whether its two first arguments are close enough, i.e. if their difference isn't more
        than the third argument multiplied by the biggest of the absolute values of the two numbers. Upon
        failure, it converts its arguments to strings, which will be shown in the output.
        This can only be used with floating point numbers, and objects
        on which <code class="code">operator-</code> is defined and for which the function <code class="code">fabs</code> is overloaded.</p><p>This Rich Boolean is to be preferred over <code class="code">rbNEAR(a,b,diff)</code> if you expect both small
        and big values for <code class="code">a</code> and <code class="code">b</code>, with about the same proportional error.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">relative difference of `a':&lt;10&gt; and `b':&lt;8.99&gt; = 0.101 &lt;= `diff':&lt;0.1&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">RelNear&lt;class GetValue1=Value, class GetValue2=Value, class GetValue3=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id507703"></a>
				<code class="code">rbLESS_REL_NEAR(a,b,diff), rbvLESS_REL_NEAR(a,b,diff)</code>
			</h4></div></div></div><a class="indexterm" name="id507705"></a><p>This macro checks whether the first argument is less than the second,
			 but allowing a tolerance of <code class="code">diff*max(a,b)</code>, i.e. if the first is between <code class="code">b</code>
			 and <code class="code">b+diff*max(a,b)</code>, it is still accepted. Upon
        failure, it converts its arguments to strings, which will be shown in the output.
        The actual difference is also shown.
        This can only be used with floating point numbers, and objects
        on which <code class="code">operator-</code> is defined and for which the function <code class="code">fabs</code> is overloaded.</p><p>Note that this is <span class="emphasis"><em>less</em></span> strict than <code class="code">rbLESS</code>.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;1.0&gt; &lt;~ `b':&lt;2.0&gt; (relative difference is &lt;0.5&gt;, `diff':&lt;0.1&gt; allowed) - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">LessRelativeNear&lt;class GetValue1=Value, class GetValue2=Value, class GetValue3=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id507772"></a>
				<code class="code">rbMORE_REL_NEAR(a,b,diff), rbvMORE_REL_NEAR(a,b,diff)</code>
			</h4></div></div></div><a class="indexterm" name="id507775"></a><p>This macro checks whether the first argument is more than the second,
			 but allowing a tolerance of <code class="code">diff*max(a,b)</code>, i.e. if the first is between <code class="code">b</code>
			 and <code class="code">b-diff*max(a,b)</code>, it is still accepted. Upon
        failure, it converts its arguments to strings, which will be shown in the output.
        The actual difference is also shown.
        This can only be used with floating point numbers, and objects
        on which <code class="code">operator-</code> is defined and for which the function <code class="code">fabs</code> is overloaded.</p><p>Note that this is <span class="emphasis"><em>less</em></span> strict than <code class="code">rbMORE</code>.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;1.0&gt; &gt;~ `b':&lt;2.0&gt; (relative difference is &lt;0.5&gt;, `diff':&lt;0.1&gt; allowed) - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">MoreRelativeNear&lt;class GetValue1=Value, class GetValue2=Value, class GetValue3=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id507842"></a>
				<code class="code">rbDIFF_REL_NEAR(a,b,diff), rbvIFF_REL_NEAR(a,b,diff)</code>
			</h4></div></div></div><a class="indexterm" name="id507844"></a><p>This macro checks whether the first argument is different from the second,
			 requiring a tolerance of <code class="code">diff*max(a,b)</code>, i.e. if the first is between <code class="code">b-diff</code>
			 and <code class="code">b+diff</code>, it is neither accepted. Upon
        failure, it converts its arguments to strings, which will be shown in the output.
        The actual difference is also shown.
        This can only be used with floating point numbers, and objects
        on which <code class="code">operator-</code> is defined and for which the function <code class="code">fabs</code> is overloaded.</p><p>Note that this is <span class="emphasis"><em>more</em></span> strict than <code class="code">rbDIFF</code>.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`a':&lt;1.0&gt; !=~`b':&lt;2.0&gt; (relative difference is &lt;1&gt;, should be at least`diff':&lt;0.1&gt;) - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">DiffRelativeNear&lt;class GetValue1=Value, class GetValue2=Value, class GetValue3=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id507912"></a>
				<code class="code">rbEQUAL_BITWISE(bits1, bits2), rbvEQUAL_BITWISE(bits1, bits2)</code>
			</h4></div></div></div><a class="indexterm" name="id507914"></a><p>This macro checks whether <code class="code">bits1</code> and <code class="code">bits2</code> are equal bitwise. They can be
            of different types, but they must have the same size. Upon failure, it will show which bits
            are different.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">1: 00001111 00000000 00000000 00000000
C:   XXXX                             
2: 00110011 00000000 00000000 00000000</pre><p>
			</p><p>Note: to display the output of this rich boolean, it is best to use a non-proportional font,
            so the comparison is easily understood.</p><p>Note: the different bytes are shown in the same order as they appear in memory,
			so the output is different on little endian and big endian machines. In a byte, the most
			significant bit is shown first, the least significant bit last.</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">EqualBitwise&lt;class GetValue1=Value, class GetValue2=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id507968"></a>
				<code class="code">rbEQUAL_DATA(buf1, buf2, size)</code>
			</h4></div></div></div><a class="indexterm" name="id507970"></a><p>This macro checks whether the buffers <code class="code">buf1</code> and <code class="code">buf2</code>
			of length <code class="code">size</code> bytes have equal contents. Upon failure, it will show which bytes
            are different.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">1: 00 15 ff 78
C:       XX   
2: 00 15 fe 78</pre><p>
			</p><p>Note: to display the output of this rich boolean, it is best to use a non-proportional font,
            so the comparison is easily understood.</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">EqualData&lt;class GetValue1=Value, class GetValue2=Value, class GetValue3=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id508023"></a>
				<code class="code">rbEQUAL_DATA_BITWISE(buf1, buf2, size)</code>
			</h4></div></div></div><a class="indexterm" name="id508026"></a><p>This macro checks whether the buffers <code class="code">buf1</code> and <code class="code">buf2</code>
			of length <code class="code">size</code> bytes have equal contents. Upon failure, it will show which bits
            are different.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">1: 00001111 00000000 11111111 00000000
C:   XXXX                             
2: 00110011 00000000 11111111 00000000</pre><p>
			</p><p>Note: to display the output of this rich boolean, it is best to use a non-proportional font,
            so the comparison is easily understood.</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">EqualDataBitwise&lt;class GetValue1=Value, class GetValue2=Value, class GetValue3=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id508078"></a>
				<code class="code">rbBITS_ON(bits, mask), rbvBITS_ON(bits, mask)</code>
			</h4></div></div></div><a class="indexterm" name="id508081"></a><p>This macro checks whether the bits that are on in <code class="code">mask</code>, are also on in <code class="code">bits</code>.
            <code class="code">bits</code> and <code class="code">mask</code> can be
            of different types, but they must have the same size. Upon failure, it will show which bits
            in <code class="code">bits</code> are not on, but should be on.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">bits: 00111100 00000000 00000000 00000000
err :       XX                           
mask: 00001111 00000000 00000000 00000000</pre><p>
			</p><p>Note: to display the output of this rich boolean, it is best to use a non-proportional font,
            so the comparison is easily understood.</p><p>Note: the different bytes are shown in the same order as they appear in memory,
			so the output is different on little endian and big endian machines. In a byte, the most
			significant bit is shown first, the least significant bit last.</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">BitsOn&lt;class GetValue1=Value, class GetValue2=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id508144"></a>
				<code class="code">rbBITS_OFF(bits, mask), rbvBITS_OFF(bits, mask)</code>
			</h4></div></div></div><a class="indexterm" name="id508147"></a><p>This macro checks whether the bits that are on in <code class="code">mask</code>, are off in <code class="code">bits</code>.
            <code class="code">bits</code> and <code class="code">mask</code> can be
            of different types, but they must have the same size. Upon failure, it will show which bits
            in <code class="code">bits</code> are not off, but should be off.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">bits: 00001111 00000000 00000000 00000000
err :       XX                           
mask: 00110011 00000000 00000000 00000000</pre><p>
			</p><p>Note: to display the output of this rich boolean, it is best to use a non-proportional font,
            so the comparison is easily understood.</p><p>Note: the different bytes are shown in the same order as they appear in memory,
			so the output is different on little endian and big endian machines. In a byte, the most
			significant bit is shown first, the least significant bit last.</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">BitsOff&lt;class GetValue1=Value, class GetValue2=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id508210"></a>
				<code class="code">rbBITS_ARE(bits, mask), rbvBITS_ARE(bits, mask)</code>
			</h4></div></div></div><a class="indexterm" name="id508213"></a><p>This macro checks whether the bits in <code class="code">bits</code> are what is specified in the string <code class="code">mask</code>.
            The string <code class="code">mask</code> contains a character <code class="code">0</code> where a bit should be off and
			a character <code class="code">1</code> where a bit should be on; a character <code class="code">#</code> means the bit can be both 0 and 1.
			Bits in the string <code class="code">mask</code> can be separated by a space, dot, colon, dash and comma.
			The number of bits in <code class="code">bits</code> and the number of bits specified in <code class="code">mask</code>
            must be the same. Upon failure, it will show which bits
            in <code class="code">bits</code> are not what is expected.</p><p>Example:
</p><pre class="programlisting">rbBITS_ARE(n, "0##0:1111 0100:#100 0000:0000 0000:0000")</pre><p>
	<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">bits: 0011:1100 0100:1000 0000:0000 0000:0000
err :        XX       X                    
mask: 0##0:1111 0100:#100 0000:0000 0000:0000</pre><p>
			</p><p>Note: to display the output of this rich boolean, it is best to use a non-proportional font,
            so the comparison is easily understood.</p><p>Note: the different bytes are shown in the same order as they appear in memory,
			so the output is different on little endian and big endian machines. In a byte, the most
			significant bit is shown first, the least significant bit last.</p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">BitsAre&lt;class GetValue1=Value, class GetValue2=Value, class Stringize=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id508300"></a><code class="code">rb1_PRED(a,pred), rbv1_PRED(a,pred)</code>, <code class="code">rb2_PRED(a,b,pred), rbv2_PRED(a,b,pred)</code>,
				<code class="code">rb3_PRED(a,b,c,pred), rbv3_PRED(a,b,c,pred)</code>, <code class="code">rb4_PRED(a,b,c,d,pred), rbv4_PRED(a,b,c,d,pred)</code></h4></div></div></div><a class="indexterm" name="id508303"></a><a class="indexterm" name="id508308"></a><a class="indexterm" name="id508312"></a><a class="indexterm" name="id508317"></a><p>These macros check whether the predicate <code class="code">pred</code> returns true if the arguments
        are given to its method <code class="code">bool operator()(...)</code>. If not,
        it converts the arguments to a string, which will be shown in the output.</p><p><code class="code">pred</code> could be a C++0X lambda if your compiler supports them (gcc 4.5 and Visual C++ 2010).</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">predicate(`a':&lt;5&gt;) - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Corresponding classes:</em></span>
			</p><p>
				<code class="classname">Pred1&lt;class GetValue1=Value, class Stringize=MakeString&gt;</code>
			</p><p>
				<code class="classname">Pred2&lt;class GetValue1=Value, class GetValue2=Value,
                class Stringize1=MakeString, class Stringize2=MakeString&gt;</code>
			</p><p>
				<code class="classname">Pred3&lt;class GetValue1=Value, class GetValue2=Value, class GetValue3=Value,
                class Stringize1=MakeString, class Stringize2=MakeString, class Stringize3=MakeString&gt;</code>
			</p><p>
				<code class="classname">Pred4&lt;class GetValue1=Value, class GetValue2=Value, class GetValue3=Value, class GetValue4=Value,
                class Stringize1=MakeString, class Stringize2=MakeString, class Stringize3=MakeString, class Stringize4=MakeString&gt;</code>
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id508404"></a><code class="code">rb1_RB(a,rb)</code>, <code class="code">rbv1_1_RB(a,rb)</code>,
			<code class="code">rb2_RB(a,b,rb)</code>, <code class="code">rbv2_1_RB(a,b,rb)</code>, <code class="code">rbv2_2_RB(a,b,rb)</code>,
			<code class="code">rb3_RB(a,b,c,rb)</code>, <code class="code">rbv3_1_RB(a,b,c,rb)</code>, <code class="code">rbv3_2_RB(a,b,c,rb)</code>,
			<code class="code">rbv3_3_RB(a,b,c,rb)</code>,
            <code class="code">rb4_RB(a,b,c,d,rb)</code>, <code class="code">rb5_RB(a,b,c,d,e,rb)</code>,
			<code class="code">rb6_RB(a,b,c,d,e,f,rb)</code></h4></div></div></div><a class="indexterm" name="id508406"></a><a class="indexterm" name="id508411"></a><a class="indexterm" name="id508416"></a><a class="indexterm" name="id508420"></a><a class="indexterm" name="id508425"></a><a class="indexterm" name="id508430"></a><p>These macros check whether the rich boolean functor <code class="code">rb</code>
			evaluates to true if the arguments
			are given to it. If not, the information in the rich boolean functor will be given.</p><p>See <a href="ar01s15.html" title="Using Rich Boolean functors in Rich Boolean macros">the section called &#8220;Using Rich Boolean functors in Rich Boolean macros&#8221;</a> on how to make a rich boolean functor.</p><p>Note: assertion macros that return a value, should use
			<code class="code">rbv&lt;n&gt;_&lt;p&gt;_RB(a,b,c,rb)</code>, where &lt;n&gt; is the number
			of arguments and &lt;p&gt; is the index of the value that should be returned.</p><p><span class="emphasis"><em>Corresponding classes:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id508509"></a>Note:</h4></div></div></div><a class="indexterm" name="id508512"></a><p>The macros in this section are pointersafe. I.e.,
        if you pass them a dereferenced pointer that is <code class="literal">NULL</code>, it will not be dereferenced,
        the evaluation will be considered to fail, and the debugging information will tell that a
        <code class="literal">NULL</code> pointer was given.
        </p><div class="example"><a name="id508530"></a><p class="title"><b>Example 1. Safely using a pointer that could be <code class="literal">NULL</code></b></p><div class="example-contents"><pre class="programlisting">
    int *p = 0;
    MOD_ASSERT(rbEQUAL(5, *p));</pre></div></div><p><br class="example-break">
        Here there will be no memory read error. Instead the <code class="code">MOD_ASSERT</code> will safely fail,
        and when streamed out, the Rich Boolean
        will return "`5':&lt;5&gt; == `*p':@0x00000000 - has bad value" (valid results are given between &lt;
        and &gt;, invalid results start with @).
        Actually, pointers whose address is up to <code class="literal">0x0000000f</code>,
        are treated the same way as a <code class="literal">NULL</code> pointer. This is handy with classes where
        pointers with a low address like <code class="literal">0x01</code>, <code class="literal">0x02</code>, ..., have a special
        meaning. Also, this means that referring to a struct or class member of a null pointer often can be done
        safely, like <code class="code">p-&gt;name</code>, as long as the member <code class="code">name</code> starts before the 16th
        byte in the struct.
        </p><p>On Windows 32 and above, uninitialized memory at every memory location is detected
        in Debug mode (using the function <code class="code">IsBadReadPtr()</code>), and handled in the same way.
		If you can use
        another function that checks for valid addresses, adjust the file <code class="filename">functors.cpp</code>. Note that functions that only
        check whether a pointer is a valid heap pointer, cannot be used for this, because the argument
        of a rich boolean can also be a variable on the stack.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id508585"></a>Comparing strings</h3></div></div></div><a class="indexterm" name="id508587"></a><a class="indexterm" name="id508594"></a><p>The Rich Booleans allows to compare strings in many ways,
        both strings that use char and widecharacter strings.
		</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id508606"></a><code class="code">rbSTRING(str1, operator, str2, compareObj)</code>, <code class="code">rbvSTRING(str1, operator, str2, compareObj)</code></h4></div></div></div><a class="indexterm" name="id508616"></a><a class="indexterm" name="id508621"></a><a class="indexterm" name="id508626"></a><p><code class="code">str1</code> and <code class="code">str2</code> are two strings. The allowed types for these
			strings are determined by <code class="code">compareObj</code>. <code class="code">operator</code> can be <code class="code">==</code>,
			<code class="code">&lt;</code>, <code class="code">&lt;=</code>, <code class="code">&gt;</code>, <code class="code">&gt;=</code> or
			<code class="code">!=</code>. <code class="code">compareObj</code> is an object of a suitable class, of which several
			classes are provided (see below).</p><p>When you check for equality, the output shows which characters are different.
            This uses dynamic matching, so missing characters are easily spotted.
            When you don't check for equality, only the first character that causes the condition
            to fail is marked; mismatches after it are not marked.</p><p><span class="emphasis"><em>Corresponding class:</em></span>
			<code class="classname">CompareStrings&lt;class CompareCompletely&lt;class CompareType, class Relation=EqualRelation&gt;
			    class GetValue1_=Value, class GetValue2_=Value&gt;</code>. Here
			    <code class="code">CompareType</code> can be any of the classes discussed below.
			    <code class="code">Relation</code> can be any of <code class="classname">EqualRelation</code>,
			    <code class="classname">LessRelation</code>, <code class="classname">LessOrEqualRelation</code>,
			    <code class="classname">MoreRelation</code>, <code class="classname">MoreOrEqualRelation</code> and
			    <code class="classname">DifferentRelation</code> (all still in the namespace
			    <code class="code">RichBool</code>).</p><p>There are two simplified versions of this Rich Boolean:
			</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="code">rbSTRING_CS(str1, operator, str2)</code>: performs a case sensitive comparison</li><li style="list-style-type: disc"><code class="code">rbSTRING_CI(str1, operator, str2)</code>: performs a case insensitive comparison</li></ul></div><p>
			These work with both ordinary and wide strings.
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id508741"></a><code class="code">rbSTRING_BEGINS_WITH(str1, str2, compareObj)</code>,
			<code class="code">rbvSTRING_BEGINS_WITH(str1, str2, compareObj)</code></h4></div></div></div><a class="indexterm" name="id508750"></a><a class="indexterm" name="id508755"></a><a class="indexterm" name="id508760"></a><p>This checks if the string <code class="code">str1</code> begins with the string <code class="code">str2</code>.
			The allowed types for these strings are determined by <code class="code">compareObj</code>.
			<code class="code">compareObj</code> is an object of a suitable class, of which several classes are provided (see below).</p><p><span class="emphasis"><em>Corresponding class:</em></span>
			<code class="classname">CompareStrings&lt;class StringBeginsWith&lt;class CompareType&gt;
			    class GetValue1_=Value, class GetValue2_=Value&gt;</code>. Here
			    <code class="code">CompareType</code> can be any of the classes discussed below.</p><p>There are two simplified versions of this Rich Boolean:
			</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="code">rbSTRING_BEGINS_WITH_CS(str1, operator, str2)</code>: performs a case sensitive comparison</li><li style="list-style-type: disc"><code class="code">rbSTRING_BEGINS_WITH_CI(str1, operator, str2)</code>: performs a case insensitive comparison</li></ul></div><p>
			These work with both ordinary and wide strings.
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id508820"></a><code class="code">rbSTRING_ENDS_WITH(str1, str2, compareObj)</code>,
			<code class="code">rbvSTRING_ENDS_WITH(str1, str2, compareObj)</code></h4></div></div></div><a class="indexterm" name="id508830"></a><a class="indexterm" name="id508834"></a><a class="indexterm" name="id508839"></a><p>This checks if the string <code class="code">str1</code> ends with the string <code class="code">str2</code>.
			The allowed types for these strings are determined by <code class="code">compareObj</code>.
			<code class="code">compareObj</code> is an object of a suitable class, of which several classes are provided (see below).</p><p><span class="emphasis"><em>Corresponding class:</em></span>
			<code class="classname">CompareStrings&lt;class StringEndsWith&lt;class CompareType&gt;
			    class GetValue1_=Value, class GetValue2_=Value&gt;</code>. Here
			    <code class="code">CompareType</code> can be any of the classes discussed below.</p><p>There are two simplified versions of this Rich Boolean:
			</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="code">rbSTRING_ENDS_WITH_CS(str1, operator, str2)</code>: performs a case sensitive comparison</li><li style="list-style-type: disc"><code class="code">rbSTRING_ENDS_WITH_CI(str1, operator, str2)</code>: performs a case insensitive comparison</li></ul></div><p>
			These work with both ordinary and wide strings.
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id508899"></a><code class="code">rbSTRING_CONTAINS(str1, str2, compareObj)</code>,
			<code class="code">rbvSTRING_CONTAINS(str1, str2, compareObj)</code></h4></div></div></div><a class="indexterm" name="id508909"></a><a class="indexterm" name="id508914"></a><a class="indexterm" name="id508918"></a><p>This checks if the string <code class="code">str1</code> contains the string <code class="code">str2</code>.
			The allowed types for these strings are determined by <code class="code">compareObj</code>.
			<code class="code">compareObj</code> is an object of a suitable class, of which several classes are provided (see below).</p><p><span class="emphasis"><em>Corresponding class:</em></span>
			<code class="classname">CompareStrings&lt;class StringContains&lt;class CompareType&gt;
			    class GetValue1_=Value, class GetValue2_=Value&gt;</code>. Here
			    <code class="code">CompareType</code> can be any of the classes discussed below.</p><p>There are two simplified versions of this Rich Boolean:
			</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="code">rbSTRING_CONTAINS_CS(str1, operator, str2)</code>: performs a case sensitive comparison</li><li style="list-style-type: disc"><code class="code">rbSTRING_CONTAINS_CI(str1, operator, str2)</code>: performs a case insensitive comparison</li></ul></div><p>
			These work with both ordinary and wide strings.
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id508978"></a>Classes to use as the last argument in string comparisons</h4></div></div></div><p>Note: the string comparisons that use collation, don't take care well of
			characters that are ignored in a collation. Dynamic matching often matches the surrounding
			characters, so ignored characters are shown as a superfluous character (or a mismatch),
			but it is up to you to know which are the false negatives. When you compare strings with
			collation but not for equality, the comparison therefor doesn't stop at the first offending character,
			because it could be an ignored character.
            </p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id508988"></a>Comparing character pointers</h5></div></div></div><a class="indexterm" name="id508993"></a><a class="indexterm" name="id508998"></a><a class="indexterm" name="id509002"></a><a class="indexterm" name="id509007"></a><a class="indexterm" name="id509012"></a><p>In the file <code class="filename">richbool/string.hpp</code> there is the template class
			<code class="classname">BasicStrcmp</code>, that has one template argument, the
            character type. You can use
            two specializations, <code class="classname">BasicStrcmp&lt;char&gt;</code> that uses <code class="code">strcmp()</code>,
            (typedef'ed as <code class="classname">Strcmp</code>)
            and <code class="classname">BasicStrcmp&lt;wchar&gt;</code> that uses <code class="code">wcscmp()</code>
            (typedef'ed as <code class="classname">Wcscmp</code>). These have a constructor that takes no arguments.
            These can only have character pointers as arguments, no string objects.
            For convenience, the Rich Booleans <code class="code">rbSTRCMP(str1, operator, str2)</code>,
            <code class="code">rbWCSCMP(str1, operator, str2)</code>, <code class="code">rbvSTRCMP(str1, operator, str2)</code> and
            <code class="code">rbvWCSCMP(str1, operator, str2)</code> are defined, that are equivalent to
            <code class="code">rbSTRING(str1, operator, str2, RichBool::Strcmp())</code>,
            <code class="code">rbSTRING(str1, operator, str2, RichBool::Wcscmp())</code>,
			<code class="code">rbvSTRING(str1, operator, str2, RichBool::Strcmp())</code>
            and <code class="code">rbvSTRING(str1, operator, str2, RichBool::Wcscmp())</code> respectively.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id509079"></a>Comparing std::string objects</h5></div></div></div><a class="indexterm" name="id509084"></a><a class="indexterm" name="id509089"></a><a class="indexterm" name="id509094"></a><a class="indexterm" name="id509098"></a><a class="indexterm" name="id509103"></a><a class="indexterm" name="id509108"></a><a class="indexterm" name="id509113"></a><a class="indexterm" name="id509118"></a><a class="indexterm" name="id509122"></a><a class="indexterm" name="id509127"></a><a class="indexterm" name="id509132"></a><a class="indexterm" name="id509137"></a><a class="indexterm" name="id509142"></a><a class="indexterm" name="id509146"></a><a class="indexterm" name="id509151"></a><p>In the file <code class="filename">richbool/stdstring.hpp</code> there is the template class
            <code class="classname">BasicStringCompare</code>, that compares <code class="classname">std::string</code> objects and/or
            character pointers using <code class="code">strcmp</code> or
            <code class="code">wcscmp</code>, depending on the character type.
            <code class="classname">BasicStringCompareToUpper</code> and
			<code class="classname">BasicStringCompareToLower</code> do the same, but first make a copy of the
            strings and convert these copies to respectively uppercase and lowercase.
            Those three template classes respectively have typedefs <code class="classname">StringCompare</code>,
            <code class="classname">StringCompareToUpper</code> and <code class="classname">StringCompareToLower</code>
            for <code class="code">char</code>, and <code class="classname">WStringCompare</code>,
            <code class="classname">WStringCompareToUpper</code> and <code class="classname">WStringCompareToLower</code>
            for <code class="code">wchar_t</code>.</p><p>For convenience, there are the Rich Booleans <code class="code">rbSTD_STRING(str1, operator, str2)</code>
			and <code class="code">rbSTD_WSTRING(str1, operator, str2)</code>
			that are respectively equivalent to <code class="code">rbSTRING(str1, operator, str2, RichBool::StringCompare())</code>
			and <code class="code">rbSTRING(str1, operator, str2, RichBool::WStringCompare())</code>. So what they check is
			equivalent to using the operators directly on the strings.</p><p>For convenience, there are the following typedefs that make comparisons in ranges easier:
			</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">typedef CompareStrings&lt;CompareCompletely&lt;StringCompare, EqualRelation&gt;, GetStringValue, GetStringValue&gt; StringsEqualCS;</li><li style="list-style-type: disc">typedef CompareStrings&lt;CompareCompletely&lt;WStringCompare, EqualRelation&gt;, GetStringValue, GetStringValue&gt; WStringsEqualCS;</li><li style="list-style-type: disc">typedef CompareStrings&lt;CompareCompletely&lt;StringCompareToUpper, EqualRelation&gt;, GetStringValue, GetStringValue&gt; StringsEqualCI;</li><li style="list-style-type: disc">typedef CompareStrings&lt;CompareCompletely&lt;WStringCompareToUpper, EqualRelation&gt;, GetStringValue, GetStringValue&gt; WStringsEqualCI;</li></ul></div><p>
			This allows you to e.g. compare strings in two std::vector objects with std::string objects in them, with
			</p><pre class="programlisting">MOD_ASSERT(
  rbIN_CONTAINERS(vec1, vec2, RichBool::Compare&lt;&gt;().That(RichBool::StringsEqualCS()))
);</pre><p>.
			</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id509262"></a>Comparing std::string objects with collation</h5></div></div></div><a class="indexterm" name="id509266"></a><a class="indexterm" name="id509271"></a><a class="indexterm" name="id509276"></a><p>In the same file <code class="filename">richbool/stdstring.hpp</code> there are also the template classes
			<code class="classname">BasicCollate</code>, <code class="classname">BasicCollateToUpper</code> and
			<code class="classname">BasicCollateToLower</code>. They have one template argument, the
            character type. These have a constructor that has a locale
			as argument, for which the global locale is the default.
            <code class="classname">BasicCollate</code> collates strings
			using the <code class="code">compare</code> method of the given locales <code class="code">collate</code> facet.
			<code class="classname">BasicCollateToUpper</code> and
			<code class="classname">BasicCollateToLower</code> also do this, but first make a copy of the strings,
            and convert these copies to upper case and lower case
			respectively, using the <code class="code">toupper</code> and <code class="code">tolower</code> methods
			of the given locales <code class="code">ctype</code> facet.</p><p>Note that converting to uppercase or lowercase only behaves differently
			if the strings contain characters between 'Z' and 'a', and when you don't check
			for equality.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id509332"></a>Comparing wxString objects</h5></div></div></div><a class="indexterm" name="id509337"></a><a class="indexterm" name="id509342"></a><p>In the file <code class="filename">richbool/wxstring.hpp</code> there are the classes
			<code class="classname">WxStringCmp</code> and <code class="classname">WxStringCmpNoCase</code>,
			that compare <code class="classname">wxString</code> objects and/or character pointers.
			These have a constructor that takes no arguments. The first one compares strings
			using the <code class="code">Cmp</code> method of <code class="classname">wxString</code>,
			the second uses the <code class="code">CmpNoCase</code> method of <code class="classname">wxString</code>.
			There is also the Rich Boolean macro <code class="code">rbWX_STRING(str1, op, str2)</code>, which is
			equivalent to <code class="code">rbSTRING(str1, op, str2, RichBool::WxStringCmp())</code></p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id509386"></a>Comparing MFC CString objects</h5></div></div></div><a class="indexterm" name="id509391"></a><a class="indexterm" name="id509396"></a><a class="indexterm" name="id509401"></a><a class="indexterm" name="id509406"></a><a class="indexterm" name="id509410"></a><a class="indexterm" name="id509415"></a><a class="indexterm" name="id509420"></a><a class="indexterm" name="id509425"></a><a class="indexterm" name="id509430"></a><a class="indexterm" name="id509434"></a><a class="indexterm" name="id509439"></a><a class="indexterm" name="id509444"></a><p>There are similar classes for MFC <code class="classname">CString</code> objects.
			In the file <code class="filename">richbool/mfcstring.hpp</code> there are the classes
			<code class="classname">CStringCompare</code>, <code class="classname">CStringCompareNoCase</code>,
			<code class="classname">CStringCollate</code> and <code class="classname">CStringCollateNoCase</code>,
			that compare <code class="classname">CString</code> objects and/or character pointers.
			These have a constructor that takes no
			arguments. They respectively compare strings
			using the methods <code class="code">Compare</code>, <code class="code">CompareNoCase</code>, <code class="code">Collate</code> and
			<code class="code">CollateNoCase</code> methods of <code class="classname">CString</code>.
			With Visual Studio .NET 2003 and later, you can also use
			<code class="classname">CStringACompare</code>, <code class="classname">CStringACompareNoCase</code>,
			<code class="classname">CStringACollate</code>, <code class="classname">CStringACollateNoCase</code>,
			<code class="classname">CStringWCompare</code>, <code class="classname">CStringWCompareNoCase</code>,
			<code class="classname">CStringWCollate</code> and <code class="classname">CStringWCollateNoCase</code>,
			which use the same methods on <code class="classname">CStringA</code> and
			<code class="classname">CStringW</code> objects.
			In template code you can use the template classes
			<code class="classname">TmplCStringCompare&lt;T&gt;</code>, <code class="classname">TmplCStringCompareNoCase&lt;T&gt;</code>,
			<code class="classname">TmplCStringCollate&lt;T&gt;</code> and <code class="classname">TmplCStringCollateNoCase&lt;T&gt;</code>,
			of which the previous ones are typedefs.</p><p>
			There is also the Rich Boolean macro <code class="code">rbCSTRING(str1, op, str2)</code>, which is
			equivalent to <code class="code">rbSTRING(str1, op, str2, RichBool::CStringCompare())</code>
            </p><p>Example usage:
			    </p><pre class="programlisting">
    String str1 = "abc";
    MOD_ASSERT(rbSTRING(str1, ==, "abd", RichBool::StringCompare()));</pre><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`str1':&lt;abc&gt; == `"abd"':&lt;abd&gt; (locale C) - nok
str1: abc
diff:   X
str2: abd</pre><p>
			</p><p>Example usage:
			    </p><pre class="programlisting">
    String str1 = "abc", str2 = "ABÉ";
    MOD_ASSERT(rbSTRING(str1, &gt;, str2, RichBool::CollateToUpper(std::locale("fr"))));</pre><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">`str1':&lt;abc&gt; &gt; `str2':&lt;ABÉ&gt; (locale French_France.1252 toupper) - nok
str1: ab   c
diff:      X
str2: ab\xc9</pre><p>
			</p></div></div><p>The next four macros are only available on compilers that support
		C++0X regular expressions. At the moment of writing this works with Visual C++ 2010, but not with gcc.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id509592"></a><code class="code">rbREGEXP(str, regex)</code>,
			<code class="code">rbvREGEXP(str, regex)</code></h4></div></div></div><a class="indexterm" name="id509601"></a><p>This checks if the string <code class="code">str</code> matches the
			regular expression in the string <code class="code">regex</code> (of the ECMAScript type).
			The strings <code class="code">str</code> and <code class="code">regex</code> can be of the <code class="code">char</code> or <code class="code">wchar</code> type,
			as long as they are the same type.
			</p><p>If the condition fails, the regular expression is split up in pieces in the analysis,
			and the analysis shows which pieces could be matched to which pieces of the regular expression.
			</p><p><span class="emphasis"><em>Corresponding class:</em></span>
			<code class="classname">RegExp&lt;class GetValue1_=Value, class GetValue2_=Value&gt;</code></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id509644"></a><code class="code">rbREGEXP_F(str, regex, flags)</code>,
			<code class="code">rbvREGEXP_F(str, regex, flags)</code></h4></div></div></div><a class="indexterm" name="id509654"></a><p>This checks if the string <code class="code">str</code> matches the
			regular expression in the string <code class="code">regex</code> (of the ECMAScript type), using the flags in <code class="code">flags</code> with <code class="code">std::regex_search</code>.
			The strings <code class="code">str</code> and <code class="code">regex</code> can be of the <code class="code">char</code> or <code class="code">wchar</code> type,
			as long as they are the same type.
			</p><p>If the condition fails, the analysis is similar to the one created by <code class="code">rbREGEXP</code>.
			</p><p><span class="emphasis"><em>Corresponding class:</em></span>
			<code class="classname">RegExp&lt;class GetValue1_=Value, class GetValue2_=Value&gt;</code></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id509708"></a><code class="code">rbHAS_REGEXP(str, regex)</code>,
			<code class="code">rbvHAS_REGEXP(str, regex)</code></h4></div></div></div><a class="indexterm" name="id509718"></a><p>This checks if the string <code class="code">str</code> contains a substring that matches the
			regular expression in the string <code class="code">regex</code> (of the ECMAScript type).
			The strings <code class="code">str</code> and <code class="code">regex</code> can be of the <code class="code">char</code> or <code class="code">wchar</code> type,
			as long as they are the same type.
			</p><p>If the condition fails, the regular expression is split up in pieces in the analysis,
			and the analysis shows which pieces could be matched to which pieces of the regular expression.
			</p><p><span class="emphasis"><em>Corresponding class:</em></span>
			<code class="classname">HasRegExp&lt;class GetValue1_=Value, class GetValue2_=Value&gt;</code></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id509761"></a><code class="code">rbHAS_REGEXP_F(str, regex, flags)</code>,
			<code class="code">rbvHAS_REGEXP_F(str, regex, flags)</code></h4></div></div></div><a class="indexterm" name="id509770"></a><p>This checks if the string <code class="code">str</code> contains a substring that matches the
			regular expression in the string <code class="code">regex</code> (of the ECMAScript type), using the flags in <code class="code">flags</code> with <code class="code">std::regex_search</code>.
			The strings <code class="code">str</code> and <code class="code">regex</code> can be of the <code class="code">char</code> or <code class="code">wchar</code> type,
			as long as they are the same type.
			</p><p>If the condition fails, the analysis is similar to the one created by <code class="code">rbHAS_REGEXP</code>.
			</p><p><span class="emphasis"><em>Corresponding class:</em></span>
			<code class="classname">HasRegExp&lt;class GetValue1_=Value, class GetValue2_=Value&gt;</code></p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id509828"></a>Filesystem</h3></div></div></div><a class="indexterm" name="id509830"></a><a class="indexterm" name="id509835"></a><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id509846"></a>
				<code class="code">rbFILE(file, func)</code>, <code class="code">rbvFILE(file, func)</code>
			</h4></div></div></div><a class="indexterm" name="id509848"></a><p><code class="code">file</code> is the name of a file, a file descriptor or a <code class="classname">FILE</code>
			pointer, <code class="code">func</code> specifies the condition(s) that the file should fulfill.
			If the file does not exist, is a directory or does not fulfill the requirements,
			the Rich Boolean fails, otherwise it succeeds. See below for what <code class="code">func</code>
			can be. If the first argument is a filename, then on Windows it can be a basic character string or a wide character string
			(except with the Cygwin compiler);
			on POSIX systems it can only be a basic character string (because POSIX doesn't have wide character filenames).</p><p>Example usage:
			    </p><pre class="programlisting">
    MOD_ASSERT(rbFILE(filename, RichBool::IsWritable()));</pre><p>
				<span class="emphasis"><em>Example output 1a (Windows):</em></span>
				</p><pre class="screen">file `filename':&lt;results.txt&gt; should be writable - nok</pre><p>
				<span class="emphasis"><em>Example output 1b (Posix):</em></span>
				</p><pre class="screen">file `filename':&lt;results.txt&gt; should be writable - nok
  -r--r----- 1 mark(1000)+ users(100)+;
  "process user and group: mark(1000) users(100)</pre><p>
				<span class="emphasis"><em>Example output 2:</em></span>
				</p><pre class="screen">file `filename':&lt;results&gt; should be writable - ? - nok
is a directory</pre><p>
			Note that on Posix systems there is an epilogue that shows the file type and
			the permissions of the file, in almost the same way as the command <code class="code">ls</code> does
			when the <code class="code">-l</code> option is given.
			The name of the user is followed by a plus if the process runs with that id as its real user id,
			a minus otherwise. The name of the group is followed by a plus if the process runs
			with a real user id that belongs to that group, a minus otherwise. If the process
			runs as a superuser, these are both replaced by asterisks.
			</p><p><span class="emphasis"><em>Corresponding class:</em></span> <code class="classname">File&lt;class Func, class GetValue1=Value&gt;</code></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id510563"></a>
				<code class="code">rbDIRECTORY(name, func)</code>, <code class="code">rbvDIRECTORY(name, func)</code>
			</h4></div></div></div><a class="indexterm" name="id510566"></a><p><code class="code">name</code> is the name of a directory,
			<code class="code">func</code> specifies the checks that the directory should fulfill.
			If the directory does not exist, is a file or does not fulfill the requirements,
			the Rich Boolean fails, otherwise it succeeds. See below for what <code class="code">func</code>
			can be. On Windows the name of the directory can be a basic character string or a wide character string
			(except with the Cygwin compiler);
			on POSIX systems it can only be a basic character string (because POSIX doesn't have wide character directory names).</p><p>Example usage:
			    </p><pre class="programlisting">
    MOD_ASSERT(rbDIRECTORY(name, RichBool::IsWritable()));</pre><p>
				<span class="emphasis"><em>Example output 1:</em></span>
				</p><pre class="screen">directory `name':&lt;results&gt; should be writable - nok</pre><p>
				<span class="emphasis"><em>Example output 2:</em></span>
				</p><pre class="screen">directory `name':&lt;results.txt&gt; should be writable - ? - nok
is a file</pre><p>
			</p><p><span class="emphasis"><em>Corresponding class:</em></span> <code class="classname">Directory&lt;class Func, class GetValue1=Value&gt;</code></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id510627"></a>Possible checks for <code class="code">rbFILE</code>, <code class="code">rbvFILE</code>,
			<code class="code">rbDIRECTORY</code> and <code class="code">rbvDIRECTORY</code></h4></div></div></div><a class="indexterm" name="id510645"></a><a class="indexterm" name="id510650"></a><a class="indexterm" name="id510655"></a><a class="indexterm" name="id510659"></a><a class="indexterm" name="id510664"></a><a class="indexterm" name="id510669"></a><a class="indexterm" name="id510674"></a><p>The following table lists the classes that you can use in <code class="code">rbFILE</code>, <code class="code">rbvFILE</code>,
			<code class="code">rbDIRECTORY</code> and <code class="code">rbvDIRECTORY</code>, and whether you can use them with
			a filename, a file descriptor or a directory, and whether it can be used on Windows. 
</p><div class="table"><a name="id510697"></a><p class="title"><b>Table 1. Possible checks for <code class="code">rbFILE</code>, <code class="code">rbvFILE</code>,
			<code class="code">rbDIRECTORY</code> and <code class="code">rbvDIRECTORY</code></b></p><div class="table-contents"><table summary="Possible checks for rbFILE, rbvFILE,
			rbDIRECTORY and rbvDIRECTORY" width="75%" border="1"><colgroup><col align="left"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="left">Class</th><th align="center">Filename</th><th align="center">File descriptor / FILE pointer</th><th align="center">Directory</th><th align="center">Windows</th></tr></thead><tbody><tr><td align="left">IsReadable</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="left">IsWritable</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="left">IsExecutable</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="left">IsPipe</td><td align="center">N</td><td align="center">Y</td><td align="center">N</td><td align="center">Y</td></tr><tr><td align="left">IsLink</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="left">IsRegular</td><td align="center">Y</td><td align="center">Y</td><td align="center">N</td><td align="center">N</td></tr><tr><td align="left">IsCharacterDevice</td><td align="center">Y</td><td align="center">Y</td><td align="center">N</td><td align="center">N</td></tr><tr><td align="left">IsBlockDevice</td><td align="center">Y</td><td align="center">Y</td><td align="center">N</td><td align="center">N</td></tr></tbody></table></div></div><p><br class="table-break">
</p><p>Note: on Windows a file or a directory is always readable (unless it is in a directory
	that is not accessible to the process).</p><p>Note: on Windows a file is considered executable if its extension is that of an executable
	file, like exe, com and bat. On Linux a file is considered executable if its mode says so.</p><p>Note: on Windows a directory is always considered executable.
	On Linux a directory is considered executable if its mode says so, meaning that the process can see the
	contents of the directory.</p><p>Note: because these are Rich Boolean functors, you can also negate them with <code class="code">operator!</code>
	and combine them with <code class="code">operator&amp;</code>.
	</p><pre class="programlisting">
    // check that the file is not writable:
    MOD_ASSERT(rbFILE(filename, !RichBool::IsWritable()));

    // check that the file is readable and writable:
    MOD_ASSERT(
        rbFILE(filename, RichBool::IsReadable()&amp;RichBool::IsWritable())
    );</pre><p>
	You could also use <code class="code">operator|</code>, <code class="code">operator||</code> and <code class="code">operator^</code>
	to combine them, but that usually is not needed. You could also use <code class="code">operator&amp;&amp;</code>
	to combine them, but then you would only see the result of the conditions up to the first one that
	failed.
	</p><p>Note: if you pass a file descriptor to <code class="code">rbFILE</code> or <code class="code">rbvFILE</code>,
	the checks test the properties
	that the file has, not the way that you opened the file. So if you open a writable
	file in readonly mode, a check using the file descriptor will tell that the file
	is writable, just as if the filename was used.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id510979"></a>User and group id on Linux</h4></div></div></div><a class="indexterm" name="id510983"></a><a class="indexterm" name="id510988"></a><p>On Linux the permissions to use a file or directory are determined using the
		file system user id and group id. These are the same as the effective user id and
		group id, except when they were set to a different value with <code class="code">setfsuid</code>
		and <code class="code">setfsgid</code>. Because these can not be queried, the Rich Booleans library
		cannot know these. If you call these functions, you should therefore call
		<code class="code">void SetFsUid(uid_t fsuid)</code> and/or <code class="code">void SetFsGid(uid_t fsgid)</code>
		(both in the namespace <code class="code">RichBool</code>)
		with the same values, so the Rich Booleans can perform these checks correctly.
		If you don't call these, the Rich Booleans library uses
		<code class="code">geteuid</code> and <code class="code">getegid</code>, i.e. the effective user id and group id.
		</p><p>Note that it is unlikely that you will need this,
		and that this is only needed when using file descriptors and pointers to <code class="code">FILE</code>
		objects.
		</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id511030"></a>
				<code class="code">rbFILE_EXISTS(file)</code>, <code class="code">rbvFILE_EXISTS(file, func)</code>
			</h4></div></div></div><a class="indexterm" name="id511033"></a><p><code class="code">file</code> is the name of a file.
			If the file does not exist, or is a directory,
			the Rich Boolean fails, otherwise it succeeds.
			On Windows the filename can be a basic character string or a wide character string;
			on POSIX systems it can only be a basic character string (because POSIX doesn't have wide character filenames).</p><p>Example usage:
			    </p><pre class="programlisting">
    MOD_ASSERT(rbFILE_EXISTS(filename));</pre><p>
				<span class="emphasis"><em>Example outputs:</em></span>
				</p><pre class="screen">file `filename':&lt;results.txt&gt; should exist - nok
 is a directory</pre><p>
			</p><p><span class="emphasis"><em>Corresponding class:</em></span> <code class="classname">FileExists&lt;class GetValue1=Value&gt;</code></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id511078"></a>
				<code class="code">rbDIRECTORY_EXISTS(name)</code>, <code class="code">rbvDIRECTORY_EXISTS(name)</code>
			</h4></div></div></div><a class="indexterm" name="id511081"></a><p><code class="code">name</code> is the name of a directory.
			If the directory does not exist, or is a file,
			the Rich Boolean fails, otherwise it succeeds.
			On Windows the name of the directory can be a basic character string or a wide character string
			(except with the Cygwin compiler);
			on POSIX systems it can only be a basic character string (because POSIX doesn't have wide character directory names).</p><p>Example usage:
			    </p><pre class="programlisting">
    MOD_ASSERT(rbDIRECTORY_EXISTS(name));</pre><p>
				<span class="emphasis"><em>Example outputs:</em></span>
				</p><pre class="screen">directory `name':&lt;results.txt&gt; should exist - nok
 is a file</pre><p>
			</p><p><span class="emphasis"><em>Corresponding class:</em></span> <code class="classname">DirectoryExists&lt;class GetValue1=Value&gt;</code></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id511126"></a>
				<code class="code">rbDOES_NOT_EXIST(name)</code>, <code class="code">rbvDOES_NOT_EXIST(name)</code>
			</h4></div></div></div><a class="indexterm" name="id511129"></a><p><code class="code">name</code> is a name.
			If a file or directory with that name exists,
			the Rich Boolean fails, otherwise it succeeds.
			On Windows the name can be a basic character string or a wide character string
			(except with the Cygwin compiler);
			on POSIX systems it can only be a basic character string (because POSIX doesn't have wide character filenames).</p><p>Example usage:
			    </p><pre class="programlisting">
    MOD_ASSERT(rbDOES_NOT_EXIST(name));</pre><p>
				<span class="emphasis"><em>Example outputs:</em></span>
				</p><pre class="screen">`name':&lt;results.txt&gt; should not exist - nok
 is a file</pre><p>
			</p><p><span class="emphasis"><em>Corresponding class:</em></span> <code class="classname">DoesNotExist&lt;class GetValue1=Value&gt;</code></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id511175"></a>
				<code class="code">GetFileLength</code>
			</h4></div></div></div><a class="indexterm" name="id511178"></a><p><code class="code">GetFileLength</code> is a function that takes one argument, a filename
			in a <code class="code">const char *</code>, <code class="code">const wchar_t *</code>, <code class="classname">std::string</code> or a <code class="classname">std::wstring</code>,
			and returns the length of the file (on Linux the filename can only be <code class="code">const char *</code> or <code class="classname">std::string</code>).</p><p>If the file does not exist or is a directory, -1 is returned.</p><p>Example usage:
			    </p><pre class="programlisting">
    MOD_ASSERT(rbLESS(RichBool::GetFileLength(filename), 512));</pre><p>
			</p></div><p>The Rich Booleans in this section are very useful in combination with
		the test directories you can make in UquoniTest:
			</p><pre class="programlisting">
	uqtTEST(ProcessDirectory)
	{
	    UquoniTest::UseDirectory dir;
	    dir.MakeFile("file1.txt", "1 2");
	    dir.MakeFile("file2.txt", "3 7");
	    ProcessDirectory(dir); // conversion to std::string
		
	    uqtASSERT(rbFILE_EXISTS(dir/"results.txt"));
	}
			</pre><p>
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id511240"></a>Type checking with RTTI</h3></div></div></div><a class="indexterm" name="id511243"></a><a class="indexterm" name="id511250"></a><p>Note: the rich booleans in this section only work when RTTI is enabled in
		your application (RTTI doesn't have to be enabled when the Rich Booleans library
		itself is built).</p><p>Warning: make sure you don't include the headerfile <code class="filename">typeinfo.h</code>
			in files where you use Rich Booleans. That file contains older versions of classes that are
			in the headerfile <code class="filename">typeinfo</code>, which is included by the Rich Booleans
			package. Including both leads to conflicts.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id511273"></a>
				<code class="code">rbEQUAL_TYPES(pobj1, pobj2)</code>, <code class="code">rbvEQUAL_TYPES(pobj1, pobj2)</code>
			</h4></div></div></div><a class="indexterm" name="id511275"></a><p><code class="code">pobj1</code> and <code class="code">pobj2</code> are two pointers to polymorph objects.
			The Rich Boolean only succeeds if they have the same type, which is checked
			at runtime. If they have different types, an
        <code class="classname">Analysis</code> object is created that tells what the types are.</p><p>Example usage:
			    </p><pre class="programlisting">
    A *a1 = new B;
    A *a2 = new C;
    MOD_ASSERT(rbEQUAL_TYPES(a1, a2));</pre><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">typeid(*`a1'):&lt;class B&gt; == typeid(*`a2'):&lt;class C&gt; - nok</pre><p>
			</p><p><span class="emphasis"><em>Corresponding class:</em></span> <code class="classname">EqualTypes&lt;class GetValue1=Value, class GetValue2=Value&gt;</code></p><p>This is especially useful when you have methods to clone polymorph objects.
			Add a non-virtual <code class="code">clone</code> method in the base class, that calls a
			protected virtual method <code class="code">do_clone</code>
			that does the actual cloning, and check if the types are equal after that call.
			If the <code class="code">do_clone</code> method is forgotten in a child class,
			it will be noticed at runtime.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id511342"></a>
				<code class="code">rbHAS_TYPE(pobj, type)</code>, <code class="code">rbvHAS_TYPE(pobj, type)</code>
			</h4></div></div></div><a class="indexterm" name="id511345"></a><p><code class="code">pobj</code> is a pointer to a polymorph object.
			The Rich Boolean only succeeds if it has the given type, which is checked
			at runtime. If it has a different type, an
        <code class="classname">Analysis</code> object is created that tells what the types are.</p><p>Example usage:
			    </p><pre class="programlisting">
    A *a = new B;
    MOD_ASSERT(rbHAS_TYPE(a, C));</pre><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">typeid(*`a'):&lt;class B&gt; == typeid(`C'):&lt;class C&gt; - nok</pre><p>
			</p><p><span class="emphasis"><em>Corresponding class:</em></span> <code class="classname">HasType&lt;typename Type, class GetValue1=Value&gt;</code></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id511394"></a>
				<code class="code">rbDYNAMIC_CASTABLE(obj, type)</code>, <code class="code">rbvDYNAMIC_CASTABLE(obj, type)</code>
			</h4></div></div></div><a class="indexterm" name="id511396"></a><p><code class="code">obj</code> is a polymorph object.
			The Rich Boolean only succeeds if the object can be casted to the given type
			with <code class="code">dynamic_cast</code>, which is checked at runtime. If it cannot be casted
			dynamically, an <code class="classname">Analysis</code> object is created that tells
			what the types are. The argument types are the same as for <code class="code">dynamic_cast</code>,
			i.e. a pointer to an object and a pointer type, or a reference to an object and
			a reference type.</p><p>Example usage:
			    </p><pre class="programlisting">
    A *a = new B;
    MOD_ASSERT(rbDYNAMIC_CASTABLE(*a1, C&amp;));
    MOD_ASSERT(rbDYNAMIC_CASTABLE(a1,  C*)); // equivalent</pre><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">typeid(`*a'):&lt;class B&gt; -&gt; typeid(`C&amp;'):&lt;class C&amp;&gt; - nok</pre><p>
			</p><p><span class="emphasis"><em>Corresponding class:</em></span> <code class="classname">DynamicCastable&lt;typename Type, class GetValue1=Value&gt;</code></p><p>Note: if your compiler can't do partial specialization of templates, you can't use
			this Rich Boolean. Instead, use <code class="code">rbDYNAMIC_CASTABLE_PTR(obj, type)</code> for pointers, or
			<code class="code">rbDYNAMIC_CASTABLE_REF(obj, type)</code> for references. Their corresponding classes respectively
			are <code class="classname">DynamicCastablePointer&lt;typename Type, class GetValue1=Value&gt;</code>
			and <code class="classname">DynamicCastableReference&lt;typename Type, class GetValue1=Value&gt;</code>.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id511472"></a>Type checking with wxWidgets</h3></div></div></div><a class="indexterm" name="id511474"></a><a class="indexterm" name="id511481"></a><p>wxWidgets provides a runtime typechecking system for classes that are derived from <code class="classname">wxObject</code>.
		For such classes, there are Rich Booleans that do runtime typechecking, equivalent to the ones for real RTTI.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id511497"></a>
				<code class="code">rbWX_EQUAL_TYPES(pobj1, pobj2)</code>, <code class="code">rbvWX_EQUAL_TYPES(pobj1, pobj2)</code>
			</h4></div></div></div><a class="indexterm" name="id511499"></a><p><code class="code">pobj1</code> and <code class="code">pobj2</code> are two pointers to polymorph objects.
			The Rich Boolean only succeeds if they have the same type, which is checked
			at runtime. If they have different types, an
        <code class="classname">Analysis</code> object is created that tells what the types are.</p><p>Example usage:
			    </p><pre class="programlisting">
    A *a1 = new B;
    A *a2 = new C;
    MOD_ASSERT(rbWX_EQUAL_TYPES(a1, a2));</pre><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">typeid(*`a1'):&lt;B&gt; == typeid(*`a2'):&lt;C&gt; - nok</pre><p>
			</p><p><span class="emphasis"><em>Corresponding class:</em></span> <code class="classname">WxEqualTypes&lt;class GetValue1=Value, class GetValue2=Value&gt;</code></p><p>This is especially useful when you have methods to clone polymorph objects.
			Add a non-virtual <code class="code">clone</code> method in the base class, that calls a
			protected virtual method <code class="code">do_clone</code>
			that does the actual cloning, and check if the types are equal after that call.
			If the <code class="code">do_clone</code> method is forgotten in a child class,
			it will be noticed at runtime.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id511567"></a>
				<code class="code">rbWX_HAS_TYPE(pobj, type)</code>, <code class="code">rbvWX_HAS_TYPE(pobj, type)</code>
			</h4></div></div></div><a class="indexterm" name="id511569"></a><p><code class="code">pobj</code> is a pointer to a polymorph object. <code class="code">type</code> is either a pointer to an object
			of the type <code class="classname">wxClassInfo</code>, or a <code class="code">const wxChar *</code> string that contains the name
			of the class. The Rich Boolean only succeeds if it has the given type, which is checked
			at runtime. If it has a different type, an
        <code class="classname">Analysis</code> object is created that tells what the types are.</p><p>Example usage:
			    </p><pre class="programlisting">
    A *a = new B;
    MOD_ASSERT(rbWX_HAS_TYPE(a, "C"));</pre><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">typeid(*`a'):&lt;class B&gt; == typeid(`C'):&lt;class C&gt; - nok</pre><p>
			</p><p><span class="emphasis"><em>Corresponding class:</em></span> <code class="classname">WxHasType&lt;class GetValue1=Value&gt;</code></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id511630"></a>
				<code class="code">rbWX_IS_KIND_OF(obj, type)</code>, <code class="code">rbvWX_IS_KIND_OF(obj, type)</code>
			</h4></div></div></div><a class="indexterm" name="id511633"></a><p>Here <code class="code">obj</code> is a pointer to a polymorph object. <code class="code">type</code> is either a pointer to an object
			of the class <code class="classname">wxClassInfo</code>, or a <code class="code">const wxChar *</code> string that contains the name
			of the class. The Rich Boolean only succeeds if the object can be casted to the given type,
			which is checked with the method <code class="code">IsKindOf</code>. If it cannot be casted,
			an <code class="classname">Analysis</code> object is created that tells
			what the types are.</p><p>Example usage:
			    </p><pre class="programlisting">
    A *a = new B;
    MOD_ASSERT(rbWX_IS_KIND_OF(a, "C"));</pre><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">typeid(`*a'):&lt;B&gt; -&gt; typeid(`C&amp;'):&lt;C&amp;&gt; - nok</pre><p>
			</p><p><span class="emphasis"><em>Corresponding class:</em></span> <code class="classname">WxIsKindOf&lt;class GetValue1=Value&gt;</code></p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id511701"></a>Logical expressions with Rich Booleans</h3></div></div></div><a class="indexterm" name="id511703"></a><a class="indexterm" name="id511711"></a><p>To use the Rich Booleans in this section, include <code class="filename">richbool/richbool.hpp</code></p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id511725"></a>
				<code class="code">rbOR(cond1, cond2)</code>
			</h4></div></div></div><a class="indexterm" name="id511727"></a><p><code class="code">cond1</code> and <code class="code">cond2</code> can be Rich Booleans
			(except for <code class="code">rbOR</code> and <code class="code">rbAND</code>) or booleans.
        Evaluation uses shortcut logic, so it evaluates <code class="code">cond1</code>, and if and only if this is false, also <code class="code">cond2</code>.
        If <code class="code">cond2</code> is also false, an
        <code class="classname">Analysis</code> object is created that contains the
        <code class="classname">Analysis</code> objects of both conditions.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">condition 1:
  `a':&lt;2&gt; == `b':&lt;1&gt; - nok
condition 2:
  `a':&lt;3&gt; &gt;= `c':&lt;4&gt; - nok</pre><p>
			</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id511792"></a>
				<code class="code">rbAND(cond1, cond2)</code>
			</h4></div></div></div><a class="indexterm" name="id511795"></a><p><code class="code">cond1</code> and <code class="code">cond2</code> can be Rich Booleans
			(except for <code class="code">rbOR</code> and <code class="code">rbAND</code>) or booleans.
        Evaluates <code class="code">cond1</code>, and if this is true, also <code class="code">cond2</code>. If the first is false, a
        <code class="classname">Analysis</code> object is created that contains the
        <code class="classname">Analysis</code> objects of the first condition. If the first is true
        and the second is false, an <code class="classname">Analysis</code> object is created with
        the <code class="classname">Analysis</code> objects of both conditions.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">condition 1:
  `a':&lt;1&gt; == `b':&lt;1&gt; - ok
condition 2:
  `a':&lt;3&gt; &gt;= `c':&lt;4&gt; - nok</pre><p>
			</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">condition 1:
  `a':&lt;2&gt; == `b':&lt;1&gt; - nok
condition 2:
  not evaluated</pre><p>
			</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id511874"></a>
				<code class="code">rbXOR(cond1, cond2)</code>
			</h4></div></div></div><a class="indexterm" name="id511876"></a><p><code class="code">cond1</code> and <code class="code">cond2</code> can be Rich Booleans
			(except for <code class="code">rbOR</code> and <code class="code">rbAND</code>) or booleans.
        It evaluates <code class="code">cond1</code> and <code class="code">cond2</code>, and succeeds if one of the conditions
		is true and one is false. If they both are true, or they both are false, an
        <code class="classname">Analysis</code> object is created that contains the
        <code class="classname">Analysis</code> objects of the two conditions.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">condition 1:
  `a':&lt;1&gt; == `b':&lt;1&gt; - ok
condition 2:
  `a':&lt;1&gt; &lt;= `c':&lt;1&gt; - ok</pre><p>
			</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"></div>Note that <code class="code">rbOR</code> and <code class="code">rbAND</code> can't be nested.
		If you try to, you will get a compile error, which was introduced on purpose.
		Otherwise, nesting <code class="code">rbOR</code> and <code class="code">rbAND</code> would give false results.
        This has to do with the complex task of maintaining the short circuit logic without losing the
        <code class="classname">Analysis</code> object.
        The next four Rich Booleans remedy that, but they have drawbacks. You most likely won't need
        them, since nesting <code class="code">rbOR</code> and <code class="code">rbAND</code> is rarely needed.
        Note that this problem is non-existent with <code class="code">rbXOR</code>, it can be used
        inside <code class="code">rbOR</code> and <code class="code">rbAND</code>.</div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id511977"></a>
				<code class="code">rbOR_DE(cond1, cond2)</code>
			</h4></div></div></div><a class="indexterm" name="id511979"></a><p>The suffix _DE here stands for "double evaluation".
        <code class="code">cond1</code> and <code class="code">cond2</code> can be Rich Booleans
        (except for <code class="code">rbOR</code> and <code class="code">rbAND</code>) or booleans. Unlike
        <code class="code">rbOR</code>, it can be used inside <code class="code">rbOR</code> and <code class="code">rbAND</code>.
        It can however, evaluate the conditions twice, which may not be desirable, but
        <code class="code">cond2</code> will only be evaluated if <code class="code">cond1</code> is false.</p><p><span class="emphasis"><em>Example output:</em></span> see rbOR</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id512042"></a>
				<code class="code">rbOR_BE(cond1, cond2)</code>
			</h4></div></div></div><a class="indexterm" name="id512044"></a><p>The suffix _BE here stands for "both evaluated".
        <code class="code">cond1</code> and <code class="code">cond2</code> can be Rich Booleans (except for <code class="code">rbOR</code>
        and <code class="code">rbAND</code>) or booleans. Unlike
        <code class="code">rbOR</code>, it can be used inside <code class="code">rbOR</code> and <code class="code">rbAND</code>.
        It will however, evaluate both conditions,
        even if the first one is true, which may not be desirable.</p><p><span class="emphasis"><em>Example output:</em></span> see rbOR</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id512099"></a>
				<code class="code">rbAND_DE(cond1, cond2)</code>
			</h4></div></div></div><a class="indexterm" name="id512102"></a><p>The suffix _DE here stands for "double evaluation".
        <code class="code">cond1</code> and <code class="code">cond2</code> can be Rich Booleans
        (except for <code class="code">rbOR</code> and <code class="code">rbAND</code>) or booleans. Unlike
        <code class="code">rbAND</code>, it can be used inside <code class="code">rbOR</code> and <code class="code">rbAND</code>.
        It can however, evaluate the conditions twice, which may not be desirable, but
        <code class="code">cond2</code> will only be evaluated if <code class="code">cond1</code> is true.</p><p><span class="emphasis"><em>Example output:</em></span> see rbAND</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id512164"></a>
				<code class="code">rbAND_BE(cond1, cond2)</code>
			</h4></div></div></div><a class="indexterm" name="id512167"></a><p>The suffix _BE here stands for "both evaluated".
        <code class="code">cond1</code> and <code class="code">cond2</code> can be Rich Booleans (except for <code class="code">rbOR</code>
        and <code class="code">rbAND</code>) or booleans. Unlike
        <code class="code">rbAND</code>, it can be used inside <code class="code">rbOR</code> and <code class="code">rbAND</code>.
        It will however, evaluate both conditions,
        even if the first one is false, which may not be desirable.</p><p><span class="emphasis"><em>Example output:</em></span> see rbAND</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id512223"></a>Exceptions</h3></div></div></div><a class="indexterm" name="id512228"></a><a class="indexterm" name="id512235"></a><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id512240"></a><code class="code">rbEXCEPTION(exc)</code></h4></div></div></div><a class="indexterm" name="id512242"></a><a class="indexterm" name="id512247"></a><p>This macro gives information about the exception <code class="code">exc</code>. Include the file
			<code class="filename">richbool/exceptions.hpp</code> if you need it. This Rich Boolean is peculiar,
			because it always fails, as an exception that was thrown is always an error. To use it
			with a certain type of exception, there should be two functions overloaded in the
			<code class="code">RichBool</code> namespace for the type:
			</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="code">GetExceptionTypeName(ExceptionType &amp;)</code>: this should return a string
			with the type name</li><li style="list-style-type: disc"><code class="code">GetExceptionInfo(ExceptionType &amp;)</code>: this should return a string with the info
			in the exception</li></ul></div><p>
		</p><div class="example"><a name="id512288"></a><p class="title"><b>Example 2. Defining overloaded functions to use <code class="code">rbEXCEPTION(exc)</code></b></p><div class="example-contents"><pre class="programlisting">
namespace RichBool {
	inline const char* GetExceptionTypeName(const MyException &amp;) {
		return "MyException";
	}
	inline std::string GetExceptionInfo(const MyException &amp;exc) {
		return exc.info();
	}
}</pre></div></div><p><br class="example-break">
		You can use the macro <code class="code">RICHBOOL_MAKE_EXCEPTION_TYPE_NAME</code> to define the
		function <code class="code">GetExceptionTypeName(ExceptionType &amp;)</code>, so the code is simplified to
		</p><div class="example"><a name="id512307"></a><p class="title"><b>Example 3. Defining overloaded functions to use <code class="code">rbEXCEPTION(exc)</code></b></p><div class="example-contents"><pre class="programlisting">
RICHBOOL_MAKE_EXCEPTION_TYPE_NAME(MyException);
namespace RichBool {
	inline std::string GetExceptionInfo(const MyException &amp;exc) {
		return exc.info();
	}
}</pre></div></div><p><br class="example-break">

		If you have a class hierarchy of exceptions, with a base class that has a (virtual) method to give information
		about the exeption, it usually suffices to overload <code class="code">GetExceptionInfo(ExceptionType &amp;)</code>
		for the base class, and use the macro <code class="code">RICHBOOL_MAKE_EXCEPTION_TYPE_NAME</code>
		for the derived classes.</p><p><span class="emphasis"><em>Corresponding class:</em></span> <code class="classname">RichBool::Exception</code></p>
		
		This Rich Boolean is useful in a catch block, because it lets you easily
		fire an assertion:
		<p>Example usage:
		    </p><pre class="programlisting">
    try {
        ...
    }
    catch (MyException &amp;exc) {
        MOD_ASSERT(rbEXCEPTION(exc));
        ...
    }</pre><p>
		</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id512343"></a>STD exceptions</h5></div></div></div><a class="indexterm" name="id512348"></a><p><code class="code">GetExceptionTypeName(ExceptionType &amp;)</code> and
		<code class="code">GetExceptionInfo(ExceptionType &amp;)</code> are already overloaded for all
		the exceptions that are defined in the C++ standard. To use these overloads, include the file
		<code class="filename">richbool/stdexceptions.hpp</code>.
		</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id512367"></a>MFC exceptions</h5></div></div></div><a class="indexterm" name="id512372"></a><p><code class="code">GetExceptionTypeName(ExceptionType &amp;)</code> and
		<code class="code">GetExceptionInfo(ExceptionType &amp;)</code> are already overloaded for all
		MFC exceptions. To use these overloads, include the file
		<code class="filename">richbool/mfcexceptions.hpp</code>.
		</p></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id512393"></a>Checking a range</h3></div></div></div><a class="indexterm" name="id512396"></a><a class="indexterm" name="id512403"></a><p>To use the Rich Booleans in this section, include <code class="filename">richbool/richbool.hpp</code>.
        </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id512419"></a>
				<code class="code">rbIN_RANGE(begin, end, check)</code>
			</h4></div></div></div><a class="indexterm" name="id512421"></a><p>This macro gives begin and end to the rich boolean functor
        <code class="code">check</code>.</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id512447"></a>
				<code class="code">rbIN_ARRAY(array, check)</code>
			</h4></div></div></div><a class="indexterm" name="id512450"></a><p>This macro gives the begin and end of the array to the rich boolean functor
        <code class="code">check</code>. It is equivalent to
        <code class="code">rbIN_RANGE(array, sizeof(array)/sizeof(array[0]), check)</code>.
		The variable <code class="code">array</code> should be an array, not a pointer.</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id512485"></a>
				<code class="code">rbIN_VALUES(initializer_list, check)</code>
			</h4></div></div></div><a class="indexterm" name="id512487"></a><p>This macro is still experimental. It is only available on compilers that support
			C++0X initializer lists. At the moment of writing this works on gcc 4.5, but not with Visual C++.</p><p>This macro gives the begin and end of the initializer list to the rich boolean functor
        <code class="code">check</code>. The initializer list should be enclosed in parens.</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p><div class="example"><a name="id512516"></a><p class="title"><b>Example 4. </b></p><div class="example-contents"><code class="code">rbIN_VALUES(({ 2, 4, 8}), Sorted&lt;&gt;())</code></div></div><br class="example-break"></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="check_range"></a>Available Rich Boolean functor classes for checking a range</h3></div></div></div><p>There are several Rich Boolean functor classes provided that work on a range, and thus can be
		given as the last argument to Rich Boolean macros that work on a range, like <code class="code">rbIN_RANGE</code>.
		Some of these can be used directly, others are actually Rich Boolean functor factories,
		i.e. they create rich boolean functors on the fly, when you give a Rich Boolean functor to
		their factory method. It should be a Rich Boolean functor that takes one argument.
		See <a href="ar01s15.html" title="Using Rich Boolean functors in Rich Boolean macros">the section called &#8220;Using Rich Boolean functors in Rich Boolean macros&#8221;</a> on how to make a rich boolean functor.
		</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id512541"></a>Sorted</h4></div></div></div><a class="indexterm" name="id512546"></a><p>The template class <code class="classname">Sorted&lt;bool multiPass=true&gt;</code>
		takes two arguments: the begin and end of a range, or the begin of a range and the number of elements to
		use in that range. It checks whether the given range is
		sorted. The template argument tells whether the range is single pass
		or multi-pass (see <a href="ar01s14.html#multi-or-single-pass" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>). Its default value is true.
		This class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the elements
		in the range (even the ones that are ok) or only the failing ones;
		the default value is false (i.e. only show the failing ones).</p><div class="example"><a name="id512561"></a><p class="title"><b>Example 5. Using Sorted to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array[] = { 1, 5, 3, 6 };
    MOD_ASSERT(rbIN_RANGE(array, array+4, Sorted&lt;&gt;()));</pre><p>The last line can be read as "assert that the range [array, array+4) is sorted".</p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">range is sorted: `array'-`array+4' - nok
X: [1]:&lt;5&gt; &lt;= [2]:&lt;3&gt; - nok</pre><p>
        The value between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;</p></div></div><br class="example-break"><div class="example"><a name="id512584"></a><p class="title"><b>Example 6. Using Sorted to check the elements of a range, also showing the good ones</b></p><div class="example-contents"><pre class="programlisting">
    // continued from previous listing
    MOD_ASSERT(rbIN_RANGE(array, array+4, Sorted&lt;&gt;(<span class="emphasis"><em>true</em></span>)));</pre><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">range is sorted: `array'-`array+4' - nok
M: [0]:&lt;1&gt; &lt;= [1]:&lt;5&gt; - ok
X: [1]:&lt;5&gt; &lt;= [2]:&lt;3&gt; - nok
M: [2]:&lt;3&gt; &lt;= [3]:&lt;6&gt; - ok</pre><p>
        </p></div></div><br class="example-break"><p>An 'M' at the begin of a line indicates success, an 'X' a failure.</p><div class="example"><a name="id512611"></a><p class="title"><b>Example 7. Using Sorted to check the elements of a range, using the number of elements</b></p><div class="example-contents"><pre class="programlisting">
    // continued from previous listing
    MOD_ASSERT(rbIN_RANGE(array, <span class="emphasis"><em>4</em></span>, Sorted&lt;&gt;()));</pre><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">range is sorted: `array'-`4' - nok
X: [1]:&lt;5&gt; &lt;= [2]:&lt;3&gt; - nok</pre><p>
        </p></div></div><br class="example-break"></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id512635"></a>SortedStrictly</h4></div></div></div><a class="indexterm" name="id512639"></a><p>The template class <code class="classname">SortedStrictly&lt;bool multiPass=true&gt;</code>
		takes two arguments: the begin and end of a range, or the begin of a range and the number of elements to
		use in that range. It checks whether the given range is
		sorted strictly (i.e. sorted and no two successive elements are equal).
		The template argument tells whether the range is single pass
		or multi-pass (see <a href="ar01s14.html#multi-or-single-pass" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>). Its default value is true.
		This class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the elements
		in the range (even the ones that are ok) or only the failing ones;
		the default value is false (i.e. only show the failing ones).</p><div class="example"><a name="id512655"></a><p class="title"><b>Example 8. Using SortedStrictly to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array[] = { 1, 3, 3, 6 };
    MOD_ASSERT(rbIN_RANGE(array, array+4, SortedStrictly&lt;&gt;()));</pre><p>The last line can be read as "assert that the range [array, array+4) is sorted strictly".</p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">range is sorted strictly: `array'-`array+4' - nok
X: [1]:&lt;3&gt; &lt; [2]:&lt;3&gt; - nok</pre><p>
        The value between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;</p></div></div><br class="example-break"><div class="example"><a name="id512678"></a><p class="title"><b>Example 9. Using SortedStrictly to check the elements of a range, also showing the good ones</b></p><div class="example-contents"><pre class="programlisting">
    // continued from previous listing
    MOD_ASSERT(rbIN_RANGE(array, array+4, SortedStrictly&lt;&gt;(<span class="emphasis"><em>true</em></span>)));</pre><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">range is sorted strictly: `array'-`array+4' - nok
M: [0]:&lt;1&gt; &lt; [1]:&lt;3&gt; - ok
X: [1]:&lt;3&gt; &lt; [2]:&lt;3&gt; - nok
M: [2]:&lt;3&gt; &lt; [3]:&lt;6&gt; - ok</pre><p>
        </p></div></div><br class="example-break"><p>An 'M' at the begin of a line indicates success, an 'X' a failure.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id512705"></a>AllUnique</h4></div></div></div><a class="indexterm" name="id469947"></a><p>The class <code class="classname">AllUnique</code>
		takes two arguments: the begin and end of a range, or the begin of a range and the number of elements to
		use in that range. It checks whether the elements in the given range are all unique.
		The range should be multi-pass (see <a href="ar01s14.html#multi-or-single-pass" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>).
		This class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the comparisons
		(even the ones that are ok) or only the failing ones;
		the default value is false (i.e. only show the failing comparisons).</p><div class="example"><a name="id469962"></a><p class="title"><b>Example 10. Using AllUnique to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array[] = { 1, 4, 6, 4 };
    MOD_ASSERT(rbIN_RANGE(array, array+4, AllUnique()));</pre><p>The last line can be read as "assert that the elements in the range [array, array+4) are all unique".</p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">all elements are unique in range: `array'-`array+4' - nok
X: [1]:&lt;4&gt; != [3]:&lt;4&gt; - nok</pre><p>
        The value between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;</p></div></div><br class="example-break"><p>An 'M' at the begin of a line indicates success, an 'X' a failure.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id469990"></a>All</h4></div></div></div><a class="indexterm" name="id469995"></a><p>The template class <code class="classname">All&lt;bool multiPass=true&gt;</code>
		is a Rich Boolean functor factory class. The Rich Boolean functors that its method <code class="code">Are</code> creates,
		check whether the given Rich Boolean functor applies to <span class="emphasis"><em>all</em></span> elements in the
		given range. These objects take two arguments: the begin and end of a range, or the begin of a range and the number of elements to
		use in that range. The template argument tells whether the range is single pass
		or multi-pass (see <a href="ar01s14.html#multi-or-single-pass" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>). Its default value is true.
		This class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the elements
		in the range (even the ones for which it is ok) or only the failing ones;
		the default value is false (i.e. only show the failing ones).</p><p>To create a Rich Boolean functor, pass a Rich Boolean functor to its method <code class="code">Are</code>.</p><div class="example"><a name="id470026"></a><p class="title"><b>Example 11. Using All to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    struct IsEven {
        bool operator()(int n) const { return n%2==0; }
    };
    int array[] = { 4, 6, 7, 10 };
    MOD_ASSERT(rbIN_RANGE(array, array+4, All&lt;&gt;().Are(Pred1&lt;IsEven&gt;())));</pre><p>The last line can be read as "assert that in the range [array, array+4) all
        elements are even".</p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to all elements in range `array'-`array+4' - nok
X: predicate([2]:&lt;7&gt;) - nok</pre><p>
        The value between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;</p></div></div><br class="example-break"><div class="example"><a name="id470049"></a><p class="title"><b>Example 12. Using All to check the elements of a range, also showing the good ones</b></p><div class="example-contents"><pre class="programlisting">
    // continued from previous listing
    MOD_ASSERT(rbIN_RANGE(array, array+4, All&lt;&gt;(<span class="emphasis"><em>true</em></span>).Are(Pred1&lt;IsEven&gt;())));</pre><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to all elements in range `array'-`array+4' - nok
M: predicate([0]:&lt;4&gt;) - ok
M: predicate([1]:&lt;6&gt;) - ok
X: predicate([2]:&lt;7&gt;) - nok
M: predicate([3]:&lt;10&gt;) - ok</pre><p>
        </p></div></div><br class="example-break">
        An 'M' at the begin of a line indicates success, an 'X' a failure.
      <div class="example"><a name="id470071"></a><p class="title"><b>Example 13. Using All to check the elements of a range, using the number of elements to use</b></p><div class="example-contents"><pre class="programlisting">
    // continued from previous listing
    MOD_ASSERT(rbIN_RANGE(array, <span class="emphasis"><em>4</em></span>, All&lt;&gt;().Are(Pred1&lt;IsEven&gt;())));</pre><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to all elements in range `array'-`4' - nok
X: predicate([2]:&lt;7&gt;) - nok</pre><p>
        </p></div></div><br class="example-break"></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id470095"></a>Has</h4></div></div></div><a class="indexterm" name="id470100"></a><p>The template class <code class="classname">Has&lt;bool multiPass=true&gt;</code>
		is a Rich Boolean functor factory class. The Rich Boolean functors that its method <code class="code">That</code> creates,
		check whether the given Rich Boolean functor applies to <span class="emphasis"><em>at least one element</em></span> in the
		given range. These functors take two arguments: the begin and end of a range, or the begin of a range and the number of elements to
		use in that range. The template argument tells whether the range is single pass
		or multi-pass (see <a href="ar01s14.html#multi-or-single-pass" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>). Its default value is true.
		This class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the elements
		in the range or just tell that there was no element for which the rich boolean
		passes;
		the default value is false (i.e. don't show the elements).</p><div class="example"><a name="id470124"></a><p class="title"><b>Example 14. Using Has to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    struct IsEven {
        bool operator()(int n) const { return n%2==0; }
    };
    int array[] = { 3, 5, 7, 9 };
    MOD_ASSERT(rbIN_RANGE(array, array+4, Has&lt;&gt;().That(Pred1&lt;IsEven&gt;())));</pre><p>The last line can be read as "assert that the range [array, array+4) has
        elements that are even".</p><span class="emphasis"><em>Output:</em></span><pre class="screen">predicate applies to all elements in range `array'-`array+4' - nok</pre></div></div><br class="example-break"><div class="example"><a name="id470145"></a><p class="title"><b>Example 15. Using Has to check the elements of a range, showing all the elements</b></p><div class="example-contents"><pre class="programlisting">
    // continued from previous listing
    MOD_ASSERT(rbIN_RANGE(array, array+4, Has&lt;&gt;(<span class="emphasis"><em>true</em></span>).That(Pred1&lt;IsEven&gt;())));</pre><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to all elements in range `array'-`array+4' - nok
X: predicate([0]:&lt;3&gt;) - nok
X: predicate([1]:&lt;5&gt;) - nok
X: predicate([2]:&lt;7&gt;) - nok
X: predicate([3]:&lt;9&gt;) - nok</pre></div></div><br class="example-break"></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id470167"></a>Unique</h4></div></div></div><a class="indexterm" name="id470172"></a><p>The template class <code class="classname">Unique&lt;bool multiPass=true&gt;</code>
		is a Rich Boolean functor factory class. The Rich Boolean functors that its method <code class="code">That</code> creates,
		check whether the given Rich Boolean functor applies to <span class="emphasis"><em>exactly one element</em></span> in the
		given range. These functors take two arguments: the begin and end of a range, or the begin of a range and the number of elements to
		use in that range. The template argument tells whether the range is single pass
		or multi-pass (see <a href="ar01s14.html#multi-or-single-pass" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>). Its default value is true.
		This class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the elements
		in the range or only the ones for which the rich boolean passes;
		the default value is false (i.e. only show the succeeding ones).</p><div class="example"><a name="id470195"></a><p class="title"><b>Example 16. Using Unique to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    struct IsEven {
        bool operator()(int n) const { return n%2==0; }
    };
    int array[] = { 3, 6, 7, 10 };
    MOD_ASSERT(rbIN_RANGE(array, array+4, Unique&lt;&gt;().That(Pred1&lt;IsEven&gt;())));</pre><p>The last line can be read as "assert that in the range [array, array+4) there is
        a unique element that is even".</p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to exactly one element in range `array'-`array+4' - nok
M: predicate([1]:&lt;6&gt;) - ok
M: predicate([3]:&lt;10&gt;) - ok</pre><p>
        Note that this is different from the previous ones: now the elements for which
        the rich boolean passes, are shown. Because there should be only one, and there are
        two, these are shown.</p></div></div><br class="example-break"><div class="example"><a name="id470218"></a><p class="title"><b>Example 17. Using Unique to check the elements of a range, also showing the good ones</b></p><div class="example-contents"><pre class="programlisting">
    // continued from previous listing
    MOD_ASSERT(rbIN_RANGE(array, array+4, Unique&lt;&gt;(<span class="emphasis"><em>true</em></span>).That(Pred1&lt;IsEven&gt;())));</pre><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to exactly one element in range `array'-`array+4' - nok
X: predicate([0]:&lt;3&gt;) - nok
M: predicate([1]:&lt;6&gt;) - ok
X: predicate([2]:&lt;7&gt;) - nok
M: predicate([3]:&lt;10&gt;) - ok</pre><p>
        </p></div></div><br class="example-break"><p>An 'M' at the begin of a line indicates success, an 'X' a failure (although the
        real failure here is that there is more than one element that doesn't 'fail').</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id470245"></a>Adjacent</h4></div></div></div><a class="indexterm" name="id470250"></a><p>The template class <code class="classname">Adjacent&lt;bool multiPass=true&gt;</code>
		is a Rich Boolean functor factory class. The Rich Boolean functors that its method <code class="code">Are</code> creates
		check whether the given Rich Boolean functor applies to <span class="emphasis"><em>all adjacent
		elements</em></span> in the
		given range. These functors take two arguments: the begin and end of a range, or the begin of a range and the number of elements to
		use in that range. The template argument tells whether the range is single pass
		or multi-pass (see <a href="ar01s14.html#multi-or-single-pass" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>). Its default value is true.
		This class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the elements
		in the range (even the ones for which it is ok) or only the failing ones;
		the default value is false (i.e. only show the failing ones).</p><div class="example"><a name="id470273"></a><p class="title"><b>Example 18. Using Adjacent to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array[] = { 10, 6, 8, 4 };
    MOD_ASSERT(rbIN_RANGE(array, array+4, Adjacent&lt;&gt;().Are(More&lt;&gt;())));</pre><p>The last line can be read as "assert that in the range [array, array+4) for every
        two adjacent elements, the first is more than the second".</p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to adjacent elements in range `array'-`array+4' - nok
X: [1]:&lt;6&gt; &gt; [2]:&lt;8&gt; - nok</pre><p>
        The value between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;</p></div></div><br class="example-break"><div class="example"><a name="id470296"></a><p class="title"><b>Example 19. Using Adjacent to check the elements of a range, also showing the good ones</b></p><div class="example-contents"><pre class="programlisting">
    // continued from previous listing
    MOD_ASSERT(rbIN_RANGE(array, array+4, Adjacent&lt;&gt;(<span class="emphasis"><em>true</em></span>).Are(More&lt;&gt;())));</pre><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to adjacent elements in range `array'-`array+4' - nok
M: [0]:&lt;10&gt; &gt; [1]:&lt;6&gt; - ok
X: [1]:&lt;6&gt; &gt; [2]:&lt;8&gt; - nok
M: [2]:&lt;8&gt; &gt; [3]:&lt;4&gt; - ok</pre><p>
        </p></div></div><br class="example-break"><p>An 'M' at the begin of a line indicates success, an 'X' a failure.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id470323"></a>AllPairs</h4></div></div></div><a class="indexterm" name="id470328"></a><p>The template class <code class="classname">AllPairs&lt;&gt;</code>
		is a Rich Boolean functor factory class. The Rich Boolean functors that its method <code class="code">Are</code> creates
		check whether the given Rich Boolean functor applies to <span class="emphasis"><em>all pairs of
		elements</em></span> in the
		given range. These functors take two arguments: the begin and end of a range, or the begin of a range and the number of elements to
		use in that range. The range should be multi-pass (see <a href="ar01s14.html#multi-or-single-pass" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>).
		This class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the comparisons
		in the range (even the ones for which it is ok) or only the failing comparisons;
		the default value is false (i.e. only show the failing comparisons).</p><div class="example"><a name="id470351"></a><p class="title"><b>Example 20. Using AllPairs to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array[] = { 10, 6, 8, 6 };
    MOD_ASSERT(rbIN_RANGE(array, array+4, AllPairs&lt;&gt;().Are(Different&lt;&gt;())));</pre><p>The last line can be read as "assert that in the range [array, array+4) for every
        pair of elements, the elements are different".</p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to all pairs in `array'-`array+4' - nok
X: [1]:&lt;6&gt; != [3]:&lt;6&gt; - nok</pre><p>
        The value between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;</p></div></div><br class="example-break"><p>An 'M' at the begin of a line indicates success, an 'X' a failure.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id470379"></a>Rich Boolean functor classes that take one argument</h4></div></div></div><a class="indexterm" name="id470383"></a><a class="indexterm" name="id470388"></a><a class="indexterm" name="id470393"></a><a class="indexterm" name="id470398"></a><a class="indexterm" name="id470403"></a><a class="indexterm" name="id470407"></a><a class="indexterm" name="id470412"></a><a class="indexterm" name="id470417"></a><a class="indexterm" name="id470422"></a><a class="indexterm" name="id470427"></a><a class="indexterm" name="id470431"></a><a class="indexterm" name="id470436"></a><p>One operation that is often performed, is checking whether a certain value
		is present in a range, or all values are less than a certain value.
		This could be done by binding an argument of the
		Rich Boolean functor classes like <code class="classname">Equal</code> and <code class="classname">Less</code>.
		To make this easier, you can use the following Rich Boolean functor classes that take one argument:
		</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="classname">Equals&lt;typename T, GetValue=Value&gt;</code>:
				checks whether its argument equals the argument given in its constructor</li><li style="list-style-type: disc"><code class="classname">IsLessThan&lt;typename T, GetValue=Value&gt;</code>:
				checks whether its argument is less than the argument given in its constructor</li><li style="list-style-type: disc"><code class="classname">IsLessOrEqualTo&lt;typename T, GetValue=Value&gt;</code>:
				checks whether its argument less than or equal to the argument given in its constructor</li><li style="list-style-type: disc"><code class="classname">IsMoreThan&lt;typename T, GetValue=Value&gt;</code>:
				checks whether its argument is more than the argument given in its constructor</li><li style="list-style-type: disc"><code class="classname">IsMoreOrEqualTo&lt;typename T, GetValue=Value&gt;</code>:
				checks whether its argument more than or equal to the argument given in its constructor</li><li style="list-style-type: disc"><code class="classname">IsDifferentFrom&lt;typename T, GetValue=Value&gt;</code>:
				checks whether its argument differs from the argument given in its constructor</li></ul></div><p>
		Their constructors take an argument of type T, which is copied.
		You can also use the following template functions to create these Rich Boolean Functors,
		that save you from specifying the template argument:
		</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="code">EqualTo(const T &amp;t)</code>: returns a Rich Boolean Functor of the class
				<code class="classname">Equals&lt;typename T, Value&gt;</code>
				and gives <code class="code">t</code> as an argument of the constructor.</li><li style="list-style-type: disc"><code class="code">LessThan(const T &amp;t)</code>: returns a Rich Boolean Functor of the class
				<code class="classname">IsLessThan&lt;typename T, Value&gt;</code>
				and gives <code class="code">t</code> as an argument of the constructor.</li><li style="list-style-type: disc"><code class="code">LessOrEqualTo(const T &amp;t)</code>: returns a Rich Boolean Functor of the class
				<code class="classname">IsLessOrEqualTo&lt;typename T, Value&gt;</code>
				and gives <code class="code">t</code> as an argument of the constructor.</li><li style="list-style-type: disc"><code class="code">MoreThan(const T &amp;t)</code>: returns a Rich Boolean Functor of the class
				<code class="classname">IsMoreThan&lt;typename T, Value&gt;</code>
				and gives <code class="code">t</code> as an argument of the constructor.</li><li style="list-style-type: disc"><code class="code">MoreOrEqualTo(const T &amp;t)</code>: returns a Rich Boolean Functor of the class
				<code class="classname">IsMoreOrEqualTo&lt;typename T, Value&gt;</code>
				and gives <code class="code">t</code> as an argument of the constructor.</li><li style="list-style-type: disc"><code class="code">IsDifferentFrom(const T &amp;t)</code>: returns a Rich Boolean Functor of the class
				<code class="classname">IsDifferentFrom&lt;typename T, Value&gt;</code>
				and gives <code class="code">t</code> as an argument of the constructor.</li></ul></div><p>
		Elements of a range are then compared to the given argument. For
		<code class="classname">Equals&lt;typename T, GetValue=Value&gt;</code> this is especially useful
		with <code class="classname">Has&lt;...&gt;</code> and <code class="classname">Unique&lt;...&gt;</code>,
		for the others it is also useful with <code class="classname">All&lt;...&gt;</code>.
		</p><div class="example"><a name="id470590"></a><p class="title"><b>Example 21. Checking if a value is present in a range</b></p><div class="example-contents">
		This example checks if 5 is present in the range [begin, end) of integers.
		<pre class="programlisting">
	MOD_ASSERT(rbIN_RANGE(begin, end, Has&lt;&gt;().That(EqualTo(5))));</pre></div></div><p><br class="example-break">
		</p><div class="example"><a name="id470599"></a><p class="title"><b>Example 22. Checking if a value is present exactly once in a range</b></p><div class="example-contents">
		This example checks if 5 is present exactly once in the range [begin, end) of integers.
		<pre class="programlisting">
	MOD_ASSERT(rbIN_RANGE(begin, end, Unique&lt;&gt;().That(EqualTo(5))));</pre></div></div><p><br class="example-break">
		</p><div class="example"><a name="id470609"></a><p class="title"><b>Example 23. Checking if all values in a range are less than 5</b></p><div class="example-contents">
		This example checks if all the integers in the range [begin, end) are less than 5.
		<pre class="programlisting">
	MOD_ASSERT(rbIN_RANGE(begin, end, All&lt;&gt;().Are(LessThan(5))));</pre></div></div><p><br class="example-break">
		</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="multi-or-single-pass"></a>Multi-pass and single-pass ranges</h3></div></div></div><p>The methods of the classes in the previous section have iterators as arguments.
		These iterators can be multi-pass or single-pass. If they are multi-pass (a copy of an
		old iterator still points to the same value), they only have to
        conform to the concept of forward iterators. This is specified by their boolean
		template argument, which should be <code class="literal">true</code> if you pass multi-pass
		iterators, <code class="literal">false</code> if you pass single-pass iterators. The default
		is <code class="literal">true</code>.
        Sometimes the concept of multi-pass input iterators is used; these can also be used as
        multi-pass iterators.
        Using single-pass iterators with a class that expects multi-pass iterators, results in
        undefined behaviour. Using multi-pass iterators with a class that expects single-pass
        iterators works fine, but is less performant.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id470645"></a>Comparing two ranges</h3></div></div></div><a class="indexterm" name="id470647"></a><a class="indexterm" name="id470655"></a><p>To use the Rich Booleans in this section, include <code class="filename">richbool/richbool.hpp</code>.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id470670"></a>
				<code class="code">rbIN_RANGES(begin1, end1, begin2, end2, check)</code>
			</h4></div></div></div><a class="indexterm" name="id470673"></a><p>This macro gives <code class="code">begin1</code>, <code class="code">end1</code>,
			<code class="code">begin2</code> and <code class="code">end2</code> to the rich boolean functor
        <code class="code">check</code>.</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id470713"></a>
				<code class="code">rbIN_ARRAYS(array1, array2, check)</code>
			</h4></div></div></div><a class="indexterm" name="id470716"></a><p>This macro gives the begin and end of both arrays to
			the rich boolean functor <code class="code">check</code>.
			It is equivalent to
            <code class="code">rbIN_RANGES(array1, array1+sizeof(array1)/sizeof(array1[0]),
            array2, array2+sizeof(array2)/sizeof(array2[0]), check)</code>.
			The variables <code class="code">array1</code> and <code class="code">array2</code> should be arrays, not pointers.</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id470753"></a>
				<code class="code">rbIN_RANGE_ARRAY(begin, end, array, check)</code>
			</h4></div></div></div><a class="indexterm" name="id470755"></a><p>This macro gives <code class="code">begin</code>, <code class="code">end</code> and 
			the begin and end of <code class="code">array</code> to
			the rich boolean functor <code class="code">check</code>, in that order.
			It is equivalent to
            <code class="code">rbIN_RANGES(begin, end, array, array+sizeof(array)/sizeof(array[0]), check)</code>.
			The variable <code class="code">array</code> should be an array, not a pointer.</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id470800"></a>
				<code class="code">rbIN_ARRAY_RANGE(array, begin, end, check)</code>
			</h4></div></div></div><a class="indexterm" name="id470802"></a><p>This macro gives the begin and end of <code class="code">array</code> and <code class="code">begin</code> and
			<code class="code">end</code> to
			the rich boolean functor <code class="code">check</code>, in that order.
			It is equivalent to
            <code class="code">rbIN_RANGES(array, array+sizeof(array)/sizeof(array[0]), begin, end, check)</code>.
			The variable <code class="code">array</code> should be an array, not a pointer.</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><p>The following 5 macros (that have VALUES in their name) are
			still experimental. They are only available on compilers that support
			C++0X initializer lists. At the moment of writing this works on gcc 4.5, but not with Visual C++.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id470850"></a>
				<code class="code">rbIN_VALUES_VALUES(il1, il2, check)</code>
			</h4></div></div></div><a class="indexterm" name="id470853"></a><p>This macro gives the begin and end of both initializer lists to
			the rich boolean functor <code class="code">check</code>.
			 The initializer lists should be enclosed in parens.</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id470880"></a>
				<code class="code">rbIN_RANGE_VALUES(begin, end, il, check)</code>
			</h4></div></div></div><a class="indexterm" name="id470883"></a><p>This macro gives <code class="code">begin</code>, <code class="code">end</code> and 
			the begin and end of <code class="code">il</code> to
			the rich boolean functor <code class="code">check</code>, in that order.
			The initializer list should be enclosed in parens.</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id470920"></a>
				<code class="code">rbIN_VALUES_RANGE(il, begin, end, check)</code>
			</h4></div></div></div><a class="indexterm" name="id470922"></a><p>This macro gives the begin and end of <code class="code">il</code> and <code class="code">begin</code> and
			<code class="code">end</code> to
			the rich boolean functor <code class="code">check</code>, in that order.
			The initializer list should be enclosed in parens.</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id470959"></a>
				<code class="code">rbIN_ARRAY_VALUES(array, il, check)</code>
			</h4></div></div></div><a class="indexterm" name="id470962"></a><p>This macro gives the begin and end of <code class="code">array</code> and 
			the begin and end of <code class="code">il</code> to
			the rich boolean functor <code class="code">check</code>, in that order.
			The initializer list should be enclosed in parens.</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id470995"></a>
				<code class="code">rbIN_VALUES_ARRAY(il, array, check)</code>
			</h4></div></div></div><a class="indexterm" name="id470998"></a><p>This macro gives the begin and end of <code class="code">il</code> and the begin and end of
			<code class="code">array</code> to
			the rich boolean functor <code class="code">check</code>, in that order.
			The initializer list should be enclosed in parens.</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="check_ranges"></a>Available classes for performing checks on two ranges</h3></div></div></div><p>There are several Rich Boolean functor classes provided that work on two ranges, and
		thus can be given as the last argument
		to Rich Boolean macros that work on two ranges, like <code class="code">rbIN_RANGES</code>.
		Some of these can be used directly, others are actually Rich Boolean functor factories,
		i.e. they create rich boolean functors on the fly, when you give a Rich Boolean functor to
		their factory method. It should be a Rich Boolean functor that takes two arguments.
		See <a href="ar01s15.html" title="Using Rich Boolean functors in Rich Boolean macros">the section called &#8220;Using Rich Boolean functors in Rich Boolean macros&#8221;</a> on how to make a rich boolean functor.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id513551"></a>AllEqual</h4></div></div></div><a class="indexterm" name="id513556"></a><p>The template class <code class="classname">AllEqual&lt;bool multiPass1=true, bool multiPass2=true&gt;</code>
		checks whether the elements in the two given ranges are equal.
		It takes four arguments for two ranges, that are each the begin and end of a range, or
		the begin of a range and the number of elements to use in that range (you can mix these two types).
		The template arguments tell whether
		the ranges are single pass
		or multi-pass (see <a href="ar01s14.html#multi-or-single-pass2" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>). Their default values are both true.
		This class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the elements
		in the range (even the ones that are equal) or only the different ones;
		the default value is false (i.e. only show the different ones).</p><div class="example"><a name="id513572"></a><p class="title"><b>Example 24. Using AllEqual to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array1[] = { 4, 6, 8, 10 }, array2[] = { 4, 6, 7, 10 };
    MOD_ASSERT(rbIN_RANGES(array1, array1+4, array2, array2+4, AllEqual&lt;&gt;()));</pre><p>The last line can be read as "assert that in the ranges [array1, array1+4) and
        [array2, array2+4) all elements are equal".
        </p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to ranges `array1'-`array1+4' and `array2'-`array2+4' - nok
X: [2]:&lt;8&gt; == [2]:&lt;7&gt; - nok</pre><p>
        The value between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;</p></div></div><br class="example-break"><div class="example"><a name="id513594"></a><p class="title"><b>Example 25. Using AllEqual to check the elements of a range, and also show the equal ones</b></p><div class="example-contents"><pre class="programlisting">
    // continued from previous listing
    MOD_ASSERT(rbIN_RANGES(array1, array1+4, array2, array2+4, AllEqual&lt;&gt;(<span class="emphasis"><em>true</em></span>)));</pre><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to ranges `array1'-`array1+4' and `array2'-`array2+4' - nok
M: [0]:&lt;4&gt; == [0]:&lt;4&gt; - ok
M: [1]:&lt;6&gt; == [1]:&lt;6&gt; - ok
X: [2]:&lt;8&gt; == [2]:&lt;7&gt; - nok
M: [3]:&lt;10&gt; == [3]:&lt;10&gt; - ok</pre></div></div><br class="example-break"><p>An 'M' at the begin of a line indicates success, an 'X' a failure.</p><div class="example"><a name="id513620"></a><p class="title"><b>Example 26. Using AllEqual to check the elements of a range, using the number of elements to use</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array1[] = { 4, 6, 8, 10 }, array2[] = { 4, 6, 7, 10 };
    MOD_ASSERT(rbIN_RANGES(array1, <span class="emphasis"><em>4</em></span>, array2, <span class="emphasis"><em>4</em></span>, AllEqual&lt;&gt;()));</pre><p>The last line can be read as "assert that in the ranges [array1, array1+4) and
        [array2, array2+4) all elements are equal".
        </p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to ranges `array1'-`4' and `array2'-`4' - nok
X: [2]:&lt;8&gt; == [2]:&lt;7&gt; - nok</pre><p>
        The value between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;</p></div></div><br class="example-break"></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id513651"></a>AllEqualUnordered</h4></div></div></div><a class="indexterm" name="id513656"></a><p>The template class <code class="classname">AllEqualUnordered&lt;bool multiPass1=true&gt;</code>
		checks whether the elements in the two given ranges are equal, <span class="emphasis"><em>in any order</em></span>.
		It takes four arguments for two ranges, that are each the begin and end of a range, or
		the begin of a range and the number of elements to use in that range (you can mix these two types).
		The template arguments tell whether the first range is single pass
		or multi-pass (see <a href="ar01s14.html#multi-or-single-pass2" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>). The second range should be muli-pass.
		The default value is true.
		This class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the elements
		in the range (even the ones that are equal) or only the different ones;
		the default value is false (i.e. only show the different ones).</p><div class="example"><a name="id513675"></a><p class="title"><b>Example 27. Using AllEqualUnordered to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array1[] = { 4, 6, 8, 10 }, array2[] = { 6, 7, 4, 10 };
    MOD_ASSERT(rbIN_RANGES(array1, array1+4, array2, array2+4,
        AllEqualUnordered&lt;&gt;()));</pre><p>The last line can be read as "assert that in the ranges [array1, array1+4) and
        [array2, array2+4) all elements are equal, in any order".
        </p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to ranges `array1'-`array1+4' and `array2'-`array2+4' - nok
1: [2]:&lt;8&gt; X  - nok
2: X [1]:&lt;7&gt; - nok</pre><p>
        The value between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;</p></div></div><br class="example-break"><div class="example"><a name="id513699"></a><p class="title"><b>Example 28. Using AllEqualUnordered to check the elements of a range, and also show the equal ones</b></p><div class="example-contents"><pre class="programlisting">
    // continued from previous listing
    MOD_ASSERT(rbIN_RANGES(array1, array1+4, array2, array2+4,
        AllEqualUnordered&lt;&gt;(<span class="emphasis"><em>true</em></span>)));</pre><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to ranges `array1'-`array1+4' and `array2'-`array2+4' - nok
M: [0]:&lt;4&gt; == [2]:&lt;4&gt; - ok
M: [1]:&lt;6&gt; == [0]:&lt;6&gt; - ok
M: [3]:&lt;10&gt; == [3]:&lt;10&gt; - ok
1: [2]:&lt;8&gt; X  - nok
2: X [1]:&lt;7&gt; - nok</pre></div></div><br class="example-break"><p>An 'M' at the begin of a line indicates success, an 'X' a failure.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id513725"></a>IsSubsetOf</h4></div></div></div><a class="indexterm" name="id513730"></a><p>The template class <code class="classname">IsSubsetOf&lt;bool multiPass1=true, bool multiPass2=true&gt;</code>
		checks whether the first range is a subset of the second.
		It takes four arguments for two ranges, that are each the begin and end of a range, or
		the begin of a range and the number of elements to use in that range (you can mix these two types).
		The template arguments tell whether the ranges are single pass
		or multi-pass (see <a href="ar01s14.html#multi-or-single-pass2" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>). At least one should be multi-pass.
		The default value for both is true.
		This class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the elements
		in the range (even the ones that are equal) or only the mismatched elements;
		the default value is false (i.e. only show the mismatches).</p><div class="example"><a name="id513746"></a><p class="title"><b>Example 29. Using IsSubsetOf to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array1[] = { 5, 3, 1 }, array2[] = { 4, 5, 1, 7, 9 };
    MOD_ASSERT(rbIN_RANGES(array1, array1+4, array2, array2+4,
        IsSubsetOf&lt;&gt;()));</pre><p>The last line can be read as "assert that the range [array1, array1+4) is a subset of the range
        [array2, array2+4)".
        </p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">`array1'-`array1+4' is subset of `array2'-`array2+4' - nok
1: [1]:&lt;3&gt; X  - nok</pre><p>
        The value between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;</p></div></div><br class="example-break"></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id513770"></a>IsSubsetOfSorted</h4></div></div></div><a class="indexterm" name="id513774"></a><p>The template class <code class="classname">IsSubsetOfSorted&lt;bool multiPass1=true&gt;</code>
		is identical to <code class="classname">IsSubsetOf&lt;bool multiPass1=true, bool multiPass2=true&gt;</code>,
		except that the second range should be random access and its elements should be sorted.
		This has the advantage that it is faster than
		<code class="classname">IsSubsetOf&lt;bool multiPass1=true, bool multiPass2=true&gt;</code>.
		Note that this does not check if the second range is sorted.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id513795"></a>IsOrderedSubsetOf</h4></div></div></div><a class="indexterm" name="id513800"></a><p>The template class <code class="classname">IsOrderedSubsetOf&lt;bool multiPass=true&gt;</code>
		checks whether the first range is a subset of the second, where the elements of the first range
		are found in the same order in the second.
		It takes four arguments for two ranges, that are each the begin and end of a range, or
		the begin of a range and the number of elements to use in that range (you can mix these two types).
		The template arguments tell whether one or both the ranges are single pass,
		or both multi-pass (see <a href="ar01s14.html#multi-or-single-pass2" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>).
		The default value is true, i.e. both are multi-pass.
		This class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the elements
		in the range (even the ones that are equal) or only the mismatched elements;
		the default value is false (i.e. only show the mismatches).</p><div class="example"><a name="id513815"></a><p class="title"><b>Example 30. Using IsOrderedSubsetOf to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array1[] = { 5, 3, 1 }, array2[] = { 4, 5, 1, 7, 3 };
    MOD_ASSERT(rbIN_RANGES(array1, array1+4, array2, array2+4,
        IsOrderedSubsetOf&lt;&gt;()));</pre><p>The last line can be read as "assert that the range [array1, array1+4) is an ordered subset of the range
        [array2, array2+4)".
        </p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">`array1'-`array1+4' is ordered subset of `array2'-`array2+4' - nok
1: [2]:&lt;1&gt; X  - nok</pre><p>
        The value between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;. In this output you see that the <code class="code">1</code> could not be matched
		after the <code class="code">3</code> was matched, because the algorithm doesn't walk backwards.</p></div></div><br class="example-break"></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id513849"></a>IsOrderedSubsetOfSorted</h4></div></div></div><a class="indexterm" name="id513854"></a><p>The template class <code class="classname">IsOrderedSubsetOfSorted&lt;bool multiPass1=true&gt;</code>
		is identical to
		<code class="classname">IsOrderedSubsetOf&lt;bool multiPass1=true, bool multiPass2=true&gt;</code>,
		except that the second range should be random access and its elements should be sorted.
		This has the advantage that it is faster than
		<code class="classname">IsOrderedSubsetOf&lt;bool multiPass1=true, bool multiPass2=true&gt;</code>.
		Note that this does not check if the second range is sorted.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id513874"></a>IsMultiSubsetOf</h4></div></div></div><a class="indexterm" name="id513879"></a><p>The template class <code class="classname">IsMultiSubsetOf&lt;bool multiPass1=true, bool multiPass2=true&gt;</code>
		checks whether the first range is a subset of the second, where an element in the first range can appear
		more than once if it appears at least once in the second range.
		It takes four arguments for two ranges, that are each the begin and end of a range, or
		the begin of a range and the number of elements to use in that range (you can mix these two types).
		The template arguments tell whether the ranges are single pass
		or multi-pass (see <a href="ar01s14.html#multi-or-single-pass2" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>). At least one should be multi-pass.
		The default value for both is true.
		This class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the elements
		in the range (even the ones that are equal) or only the mismatched elements;
		the default value is false (i.e. only show the mismatches).</p><div class="example"><a name="id513894"></a><p class="title"><b>Example 31. Using IsSubsetOf to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array1[] = { 5, 3, 5, 1, 1, 5 }, array2[] = { 4, 5, 1, 7, 9 };
    MOD_ASSERT(rbIN_RANGES(array1, array1+4, array2, array2+4,
        IsMultiSubsetOf&lt;&gt;()));</pre><p>The last line can be read as "assert that the range [array1, array1+4) is a multisubset of the range
        [array2, array2+4)".
        </p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">`array1'-`array1+4' is multisubset of `array2'-`array2+4' - nok
1: [1]:&lt;3&gt; X  - nok</pre><p>
        The value between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;</p></div></div><br class="example-break"></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id513918"></a>IsMultiSubsetOfSorted</h4></div></div></div><a class="indexterm" name="id513923"></a><p>The template class <code class="classname">IsMultiSubsetOfSorted&lt;bool multiPass1=true&gt;</code>
		is identical to <code class="classname">IsMultiSubsetOf&lt;bool multiPass1=true, bool multiPass2=true&gt;</code>,
		except that the second range should be random access and its elements should be sorted.
		This has the advantage that it is faster than
		<code class="classname">IsMultiSubsetOf&lt;bool multiPass1=true, bool multiPass2=true&gt;</code>.
		Note that this does not check if the second range is sorted.</p></div><p>Note that the concepts of `ordered subset' and `multisubset' don't exist in the usual
		mathematical theory of sets, because there an element can appear only once in a set,
		and sets don't have an order. Many C++ containers don't have these restrictions.</p><p>Note: it is obvious that an optimization could be made for subsets and multisubsets if the second range is a
		<code class="classname">std::set</code>, <code class="classname">std::multiset</code> etc. This will be done
		in a future release.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id513958"></a>Compare</h4></div></div></div><a class="indexterm" name="id513963"></a><p>The template class <code class="classname">Compare&lt;bool multiPass1=true, bool multiPass2=true&gt;</code>
		is a Rich Boolean functor factory class. The Rich Boolean functors that its method <code class="code">That</code> creates,
		check whether the given Rich Boolean functor applies to the <span class="emphasis"><em>corresponding elements</em></span> in the
		given ranges.
		These functors can be used in Rich Booleans that work on two ranges or containers
		(because they take four arguments for two ranges, that are each the begin and end of a range, or
		the begin of a range and the number of elements to use in that range - you can mix these two types).
		The template arguments tell whether the ranges are single pass
		or multi-pass (see <a href="ar01s14.html#multi-or-single-pass2" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>). Their default values are both true.
		This class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the elements
		in the range (even the ones for which it is ok) or only the failing ones;
		the default value is false (i.e. only show the failing ones).</p><div class="example"><a name="id513986"></a><p class="title"><b>Example 32. Using Compare to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array1[] = { 1, 4, 8, 9, 11 }, array2[] = { 4, 6, 7, 10 };
    MOD_ASSERT(rbIN_RANGES(array1, array1+5, array2, array2+4,
        Compare&lt;&gt;().That(Less&lt;&gt;())));</pre><p>The last line can be read as "assert that when the ranges [array1, array1+5) and
        [array2, array2+4) are compared, the elements in the first are less than
        the elements in the second".</p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to ranges `array1'-`array1+5' and `array2'-`array2+4' - nok
X: [2]:&lt;8&gt; &lt; [2]:&lt;7&gt; - nok
1: [4]:&lt;11&gt; X - nok</pre><p>
        The number between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;. An 'M' at the begin of a line indicates success, an 'X' a failure,
		a '1' an unmatched element in the first range, a '2' an unmatched element in the second range.</p></div></div><br class="example-break"><div class="example"><a name="id514008"></a><p class="title"><b>Example 33. Using Compare to check the elements of a range, also showing the good ones</b></p><div class="example-contents"><pre class="programlisting">
    // continued from previous listing
    MOD_ASSERT(rbIN_RANGES(array1, array1+5, array2, array2+4,
        Compare&lt;&gt;(<span class="emphasis"><em>true</em></span>).That(Less&lt;&gt;())));</pre><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to ranges `array1'-`array1+4' and `array2'-`array2+4' - nok
M: [0]:&lt;1&gt; &lt; [0]:&lt;4&gt; - ok
M: [1]:&lt;4&gt; &lt; [1]:&lt;6&gt; - ok
X: [2]:&lt;8&gt; &lt; [2]:&lt;7&gt; - nok
M: [3]:&lt;9&gt; &lt; [3]:&lt;10&gt; - ok
1: [4]:&lt;11&gt; X - nok</pre><p>
        </p></div></div><br class="example-break"></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id514032"></a>CompareUnordered</h4></div></div></div><a class="indexterm" name="id514037"></a><p>The template class <code class="classname">CompareUnordered&lt;bool multiPass1=true&gt;</code>
		is a Rich Boolean functor factory class. The Rich Boolean functors that its method <code class="code">That</code> creates,
		check whether the given rich boolean functor applies to the elements in the
		given ranges, <span class="emphasis"><em>in any order</em></span>.
		These objects can be used in Rich Booleans that work on two ranges or containers
		(because they take four arguments for two ranges, that are each the begin and end of a range, or
		the begin of a range and the number of elements to use in that range - you can mix these two types).
		The template argument tells whether the first range is single pass
		or multi-pass (see <a href="ar01s14.html#multi-or-single-pass2" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>). The default value is true. The second range should always be multi-pass.
		This class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the elements
		in the range (even the ones for which it is ok) or only the failing ones;
		the default value is false (i.e. only show the failing ones).</p><div class="example"><a name="id514060"></a><p class="title"><b>Example 34. Using CompareUnordered to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array1[] = { 2, 3, 1 }, array2[] = { 3, 0, 2 };
    MOD_ASSERT(rbIN_RANGES(array1, array1+3, array2, array2+3,
        CompareUnordered&lt;&gt;().That(Equal&lt;&gt;())));</pre><p>The last line can be read as "assert that when the ranges [array1, array1+3) and
        [array2, array2+3) are compared unordered, the elements in the first are equal to
        the elements in the second".</p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to unordered ranges `a'-`a+3' and `b'-`b+3' - nok
1: [2]:&lt;1&gt; X  - nok
2: X [1]:&lt;0&gt; - nok</pre><p>
        The number between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;. A '1' at the begin of a line indicates an
		unmatched element in the first range, a '2' an unmatched element in the second range.</p></div></div><br class="example-break"><div class="example"><a name="id514083"></a><p class="title"><b>Example 35. Using CompareUnordered to check the elements of a range, also showing the good ones</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array1[] = { 2, 3, 1 }, array2[] = { 3, 0, 2 };
    MOD_ASSERT(rbIN_RANGES(array1, array1+3, array2, array2+3,
        CompareUnordered&lt;&gt;(<span class="emphasis"><em>true</em></span>).That(Equal&lt;&gt;())));</pre><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">predicate applies to unordered ranges `a'-`a+3' and `b'-`b+3' - nok
M: [0]:&lt;2&gt; == [2]:&lt;2&gt; - ok
M: [1]:&lt;3&gt; == [0]:&lt;3&gt; - ok
1: [2]:&lt;1&gt; X  - nok
2: X [1]:&lt;0&gt; - nok</pre><p>
        An 'M' at the begin of a line indicates success,
		a '1' an unmatched element in the first range, a '2' an unmatched element in the second range.</p></div></div><br class="example-break"></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id514107"></a>MatchesSubsetOf</h4></div></div></div><a class="indexterm" name="id514112"></a><p>The template class <code class="classname">MatchesSubsetOf&lt;bool multiPass1=true, bool multiPass2=true&gt;</code>
		is a Rich Boolean factory, that has a method <code class="code">That</code> that has a Rich Boolean functor
		<code class="code">rb</code>
		as an argument, and returns a Rich Boolean functor that checks whether for every element <code class="code">a</code>
		in the first range there
		is an element <code class="code">b</code> in the second for which <code class="code">rb(a, b)</code> returns <code class="code">true</code>,
		where every element in the second range can be matched to only one element in the first range.
		The Rich Boolean object that is returned by <code class="code">That</code> can be used in Rich Booleans
		that work on two ranges or containers (because it takes four arguments for two ranges,
		that are each the begin and end of a range, or
		the begin of a range and the number of elements to use in that range - you can mix these two types).
		The template arguments tell whether the ranges are single pass
		or multi-pass (see <a href="ar01s14.html#multi-or-single-pass2" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>). At least one should be multi-pass.
		The default value for both is true.
		This template class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the elements
		in the range (even the ones that are equal) or only the mismatched elements;
		the default value is false (i.e. only show the mismatches).</p><div class="example"><a name="id514152"></a><p class="title"><b>Example 36. Using MatchesSubsetOf to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    Pred2&lt;ProductIs12&gt; productIs12;
    int array1[] = { 4, 3, 1, 3 }, array2[] = { 12, 4, 5, 9 };
    MOD_ASSERT(rbIN_RANGES(array1, array1+4, array2, array2+4,
        MatchesSubsetOf&lt;&gt;().That(productIs12)));</pre><p>The last line can be read as "assert that the range [array1, array1+4) matches with a subset of the range [array2, array2+4) where the product is 12".
        </p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">`array1'-`array1+4' matches subset of `array2'-`array2+4' - nok
1: [0]:&lt;4&gt; X  - nok
1: [3]:&lt;3&gt; X  - nok</pre><p>
        The value between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;</p></div></div><br class="example-break"></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id514176"></a>MatchesMultiSubsetOf</h4></div></div></div><a class="indexterm" name="id514181"></a><p>The template class <code class="classname">MatchesMultiSubsetOf&lt;bool multiPass1=true, bool multiPass2=true&gt;</code>
		is a Rich Boolean factory, that has a method <code class="code">That</code> that has a Rich Boolean functor
		<code class="code">rb</code>
		as an argument, and returns a Rich Boolean that checks whether for every element <code class="code">a</code>
		in the first range there
		is an element <code class="code">b</code> in the second for which <code class="code">rb(a, b)</code> returns <code class="code">true</code>,
		where every element in the second range can be matched to more than one element in the first range.
		The Rich Boolean object that is returned by <code class="code">That</code> takes four arguments for two ranges,
		that are each the begin and end of a range, or
		the begin of a range and the number of elements to use in that range (you can mix these two types).
		The template arguments tell whether the ranges are single pass
		or multi-pass (see <a href="ar01s14.html#multi-or-single-pass2" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>). At least one should be multi-pass.
		The default value for both is true.
		This template class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the elements
		in the range (even the ones that are equal) or only the mismatched elements;
		the default value is false (i.e. only show the mismatches).</p><div class="example"><a name="id514222"></a><p class="title"><b>Example 37. Using MatchesMultiSubsetOf to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
	Pred2&lt;ProductIs12&gt; productIs12;
    int array1[] = { 4, 3, 1, 3 }, array2[] = { 12, 4, 5, 9 };
    MOD_ASSERT(rbIN_RANGES(array1, array1+4, array2, array2+4,
        MatchesMultiSubsetOf&lt;&gt;().That(productIs12)));</pre><p>The last line can be read as "assert that the range [array1, array1+4) matches with a subset of the range [array2, array2+4) where the product is 12".
        </p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">`array1'-`array1+4' matches subset of `array2'-`array2+4' - nok
1: [0]:&lt;4&gt; X  - nok</pre><p>
        The value between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;. Note that both threes in the first range are matched
		to the four in the second range.</p></div></div><br class="example-break"></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id514247"></a>MatchesOrderedSubsetOf</h4></div></div></div><a class="indexterm" name="id514252"></a><p>The template class <code class="classname">MatchesOrderedSubsetOf&lt;bool multiPass1=true, bool multiPass2=true&gt;</code>
		is a Rich Boolean factory, that has a method <code class="code">That</code> that has a Rich Boolean functor
		<code class="code">rb</code>
		as an argument, and returns a Rich Boolean that checks whether for every element <code class="code">a</code>
		in the first range there
		is an element <code class="code">b</code> in the second for which <code class="code">rb(a, b)</code> returns <code class="code">true</code>,
		where the matched elements in the second range are in the same order as the elements in the first range.
		The Rich Boolean object that is returned by <code class="code">That</code> takes four arguments for two ranges,
		that are each the begin and end of a range, or
		the begin of a range and the number of elements to use in that range (you can mix these two types).
		The template arguments tell whether the ranges are single pass
		or multi-pass (see <a href="ar01s14.html#multi-or-single-pass2" title="Multi-pass and single-pass ranges">the section called &#8220;Multi-pass and single-pass ranges&#8221;</a>). At least one should be multi-pass.
		The default value for both is true.
		This template class has a constructor that takes a boolean, that tells
		whether the analysis should contain the analysis for all the elements
		in the range (even the ones that are equal) or only the mismatched elements;
		the default value is false (i.e. only show the mismatches).</p><div class="example"><a name="id514293"></a><p class="title"><b>Example 38. Using MatchesOrderedSubsetOf to check the elements of a range</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
	Pred2&lt;ProductIs12&gt; productIs12;
    int array1[] = { 4, 3, 1, 6 }, array2[] = { 4, 2, 12, 9 };
    MOD_ASSERT(rbIN_RANGES(array1, array1+4, array2, array2+4,
        MatchesOrderedSubsetOf&lt;&gt;().That(productIs12)));</pre><p>The last line can be read as "assert that the range [array1, array1+4) matches with a subset of the range [array2, array2+4) where the product is 12".
        </p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">`array1'-`array1+4' matches subset of `array2'-`array2+4' - nok
1: [0]:&lt;4&gt; X  - nok
1: [3]:&lt;6&gt; X  - nok</pre><p>
        The value between [ ] is the index of the element in the range. The value
        of the element is between &lt; &gt;. Note that the 6 could not be matched with the 2,
		because the 1 was already matched with the 12, so matching the 6 with the 2 would violate
		the order.</p></div></div><br class="example-break"></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id514318"></a>IsSubsetOfCustomSorted</h4></div></div></div><a class="indexterm" name="id514323"></a><p>The template class <code class="classname">IsSubsetOfCustomSorted&lt;bool multiPass1=true&gt;</code>
		is a Rich Boolean factory, whose method <code class="code">By</code> takes a predicate <code class="code">pred</code>
		as an argument and returns a Rich Boolean identical to
		<code class="classname">IsSubsetOf&lt;bool multiPass1=true&gt;</code>,
		except that the second range should be sorted by <code class="code">pred</code>, i.e. such that for every element
		<code class="code">a</code> that is followed by an element <code class="code">b</code>, <code class="code">pred(a, b)</code> returns
		<code class="code">true</code>.
		This has the advantage that it is faster than
		<code class="classname">IsSubsetOf&lt;bool multiPass1=true, bool multiPass2=true&gt;</code>.
		Note that this does not check if the second range is sorted.</p><div class="example"><a name="id514368"></a><p class="title"><b>Example 39. Using IsSubsetOfCustomSorted to check the elements of two ranges</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array1[] = { 4, 3, 1, 6 }, array2[] = { 9, 6, 4, 2, 1 };
    MOD_ASSERT(rbIN_RANGES(array1, array1+4, array2, array2+5,
        IsSubsetOfCustomSorted&lt;&gt;().By(more)));</pre><p>The last line can be read as "assert that the range [array1, array1+4) is a subset of the range [array2, array2+5)".
        </p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">`array1'-`array1+4' is subset of `array2'-`array2+5' - nok
1: [2]:&lt;1&gt; X  - nok</pre><p>
		</p></div></div><br class="example-break"></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id514392"></a>IsMultiSubsetOfCustomSorted</h4></div></div></div><a class="indexterm" name="id514397"></a><p>The template class <code class="classname">IsMultiSubsetOfCustomSorted&lt;bool multiPass1=true&gt;</code>
		is a Rich Boolean factory, whose method <code class="code">By</code> takes a predicate <code class="code">pred</code>
		as an argument and returns a Rich Boolean identical to
		<code class="classname">IsMultiSubsetOf&lt;bool multiPass1=true&gt;</code>,
		except that the second range should be sorted by <code class="code">pred</code>, i.e. such that for every element
		<code class="code">a</code> that is followed by an element <code class="code">b</code>, <code class="code">pred(a, b)</code> returns
		<code class="code">true</code>.
		This has the advantage that it is faster than
		<code class="classname">IsMultiSubsetOf&lt;bool multiPass1=true, bool multiPass2=true&gt;</code>.
		Note that this does not check if the second range is sorted.</p><div class="example"><a name="id514444"></a><p class="title"><b>Example 40. Using IsMultiSubsetOfCustomSorted to check the elements of two ranges</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array1[] = { 4, 3, 6, 1, 6 }, array2[] = { 9, 6, 4, 2, 1 };
    MOD_ASSERT(rbIN_RANGES(array1, array1+5, array2, array2+5,
        IsMultiSubsetOfCustomSorted&lt;&gt;().By(more)));</pre><p>The last line can be read as "assert that the range [array1, array1+=54) is a multi subset of the range [array2, array2+5)".
        </p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">`array1'-`array1+5' is multisubset of `array2'-`array2+5' - nok
1: [2]:&lt;3&gt; X  - nok</pre><p>
		Note that the six in the first range is matched twice with the same six in the second range.
		</p></div></div><br class="example-break"></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id514468"></a>IsOrderedSubsetOfCustomSorted</h4></div></div></div><a class="indexterm" name="id514473"></a><p>The template class <code class="classname">IsOrderedSubsetOfCustomSorted&lt;bool multiPass1=true&gt;</code>
		is a Rich Boolean factory, whose method <code class="code">By</code> takes a predicate <code class="code">pred</code>
		as an argument and returns a Rich Boolean identical to
		<code class="classname">IsOrderedSubsetOf&lt;bool multiPass1=true&gt;</code>,
		except that the second range should be sorted by <code class="code">pred</code>, i.e. such that for every element
		<code class="code">a</code> that is followed by an element <code class="code">b</code>, <code class="code">pred(a, b)</code> returns
		<code class="code">true</code>.
		This has the advantage that it is faster than
		<code class="classname">IsOrderedSubsetOf&lt;bool multiPass1=true, bool multiPass2=true&gt;</code>.
		Note that this does not check if the second range is sorted.</p><div class="example"><a name="id514520"></a><p class="title"><b>Example 41. Using IsOrderedSubsetOfCustomSorted to check the elements of two ranges</b></p><div class="example-contents"><pre class="programlisting">
    using namespace RichBool;
    int array1[] = { 4, 6, 3, 1 }, array2[] = { 9, 6, 4, 2, 1 };
    MOD_ASSERT(rbIN_RANGES(array1, array1+4, array2, array2+5,
        IsOrderedSubsetOfCustomSorted&lt;&gt;().By(more)));</pre><p>The last line can be read as "assert that the range [array1, array1+4) is a subset of the range [array2, array2+5)".
        </p><p><span class="emphasis"><em>Output:</em></span>
        </p><pre class="screen">`array1'-`array1+4' is subset of `array2'-`array2+5' - nok
1: [1]:&lt;6&gt; X  - nok
1: [2]:&lt;3&gt; X  - nok</pre><p>
		Note that the 6 could not be matched, because the 4 was already matched in the second range,
		which comes after the 6 in the second range.
		</p></div></div><br class="example-break"></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="multi-or-single-pass2"></a>Multi-pass and single-pass ranges</h3></div></div></div><p>The methods of the classes in the previous
		section have iterators as arguments.
		These iterators can be multi-pass or single-pass. If they are multi-pass (a copy of an
		old iterator still points to the same value), they only have to
        conform to the concept of forward iterators. This is specified by the two boolean
		template arguments of the classes, which should be <code class="literal">true</code> if you pass multi-pass
		iterators, <code class="literal">false</code> if you pass single-pass iterators. The first boolean
		applies to the first range, the second boolean applies to the second range.
		If one is single-pass and the other is multi-pass, the single-pass should be the first range
		(the specializations <code class="code">&lt;true, false&gt;</code> are not defined,
		because the specializations <code class="code">&lt;false, true&gt;</code> can be used by swapping
		the arguments). The default for both is <code class="literal">true</code>.
        Sometimes the concept of multi-pass input iterators is used; these can also be used as
        multi-pass iterators.
        Using single-pass iterators where multi-pass iterators are expected, results in
        undefined behaviour. Using multi-pass iterators where single-pass
        iterators are expected works fine, but is less performant.</p><p>Note: if both ranges are single-pass, you have to supply both template arguments,
        but in that case you can not define the object inside
        the macro, because the preprocessor doesn't understand templates, and would suppose
        that it is two arguments of the macro, and therefore it doesn't compile.
        Adding parentheses only works portably if you give an argument to its constructor
        (because of C++ parsing rules), so give false or true as an argument to the
        constructor. An alternative is to define the object before the macro.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id514577"></a>Dynamic matching</h3></div></div></div><a class="indexterm" name="id514582"></a><p><code class="classname">Compare&lt;...&gt;</code> and <code class="classname">AllEqual&lt;...&gt;</code>
	from the previous sections perform dynamic matching. This means that if a mismatch is found
	between two elements, it will try to search a match for each of the two in the following
	ten elements (if at least one of the two ranges is multi-pass). In fact it even does more than that
	if the two ranges are both multi-pass; in that case it checks which of the ten next elements in
	both ranges matches with which, and finds an optimal path.</p><p>This means that elements may be unmatched. This is shown with a '1' or '2' instead of
	'M' or 'X' at the begin of a line, to indicate that an unmatched element is only in the first
	or second range. Suppose you have two ranges of integers with the values { 1, 2, 12, 3 } and
	{ 1, 10, 2, 3 }, and compare them with <code class="classname">AllEqual&lt;...&gt;</code>. Then the
	output would be
        </p><pre class="screen">predicate does not apply on ranges `array1'-`array1+' and `array2'-`array2+4'
M: [0]:&lt;1&gt; == [0]:&lt;1&gt; - ok
2: X   [1]:&lt;10&gt;
M: [1]:&lt;2&gt; == [2]:&lt;2&gt; - ok
1: [2]:&lt;12&gt;   X
M: [3]:&lt;3&gt; == [3]:&lt;3&gt; - ok</pre><p>
    An X represents the missing element in the other range.
    </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id514608"></a>Containers with methods <code class="code">begin()</code> and <code class="code">end()</code></h3></div></div></div><p>To use the Rich Booleans in this section, include <code class="filename">richbool/containers.hpp</code>.</p><p>Note: The containers that are given to the Rich Booleans in this section, should have
        const methods <code class="code">begin()</code> and <code class="code">end()</code> that return iterators that together
        specify the range of the container. Containers in the standard template library have
        such methods, but every other container that has these methods can be used. Furthermore
        the elements in the containers should be streamable (see <a href="ar01s12.html" title="Choose your strings">the section called &#8220;Choose your strings&#8221;</a>).
        </p><p>Note: The containers that are given to the Rich Booleans that take two containers, can be of different types,
        e.g. <code class="classname">std::vector</code> and <code class="classname">std::list</code>.
        Even their elements can be of different types, as long as the Rich Boolean functor
        can have them as arguments.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id514653"></a>
				<code class="code">rbIN_CONTAINER(container, check)</code>
			</h4></div></div></div><a class="indexterm" name="id514655"></a><p>This macro checks whether the elements in the container fulfill
            the check, by giving <code class="code">container.begin()</code> and <code class="code">container.end()</code>
            to <code class="code">check</code>. It is equivalent to
            <code class="code">rbIN_RANGE(container.begin(), container.end(), check)</code>.
            See <a href="ar01s14.html#check_range" title="Available Rich Boolean functor classes for checking a range">the section called &#8220;Available Rich Boolean functor classes for checking a range&#8221;</a> for possible choices for
            <code class="code">check</code></p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">InContainer&lt;class Algorithm, class GetValue1=Value&gt;</code>
				This class has the following constructors:
				</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">a default constructor</li><li style="list-style-type: disc">a constructor that takes one argument of the type
				        <code class="classname">Algorithm</code></li></ul></div><p>
				If the default constructor is used, the default constructor of
				<code class="classname">Algorithm</code> is called.
				Objects of this template class can also be made with the template function
				<code class="code">template&lt;Algorithm&gt; InContainer&lt;class Algorithm&gt;
				MakeInContainer(Algorithm algorithm)</code>.
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id514726"></a>
				<code class="code">rbIN_CONTAINERS(container1, container2, check)</code>
			</h4></div></div></div><a class="indexterm" name="id514728"></a><p>This macro checks whether the elements in the containers fulfill
            the check, by giving <code class="code">container1.begin()</code>, <code class="code">container1.end()</code>,
            <code class="code">container2.begin()</code> and <code class="code">container2.end()</code>
            to <code class="code">check</code>. It is equivalent to
            <code class="code">rbIN_RANGES(container1.begin(), container1.end(), 
            container2.begin(), container2.end(), check)</code>.
            See <a href="ar01s14.html#check_ranges" title="Available classes for performing checks on two ranges">the section called &#8220;Available classes for performing checks on two ranges&#8221;</a> for possible choices for
            <code class="code">check</code></p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">InContainers&lt;class Algorithm, class GetValue1=Value&gt;</code>
				This class has the following constructors:
				</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">a default constructor</li><li style="list-style-type: disc">a constructor that takes one argument of the type
				        <code class="classname">Algorithm</code></li></ul></div><p>
				If the default constructor is used, the default constructor of
				<code class="classname">Algorithm</code> is called.
				Objects of this template class can also be made with the template function
				<code class="code">template&lt;Algorithm&gt; InContainers&lt;class Algorithm&gt;
				MakeInContainers(Algorithm algorithm)</code>.
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id514806"></a>
				<code class="code">rbIN_CONTAINER_RANGE(container, begin, end, check)</code>
			</h4></div></div></div><a class="indexterm" name="id514809"></a><p>This macro checks whether the elements in the container and the range
			<code class="code">[begin, end)</code> fulfill
            the check, by giving <code class="code">container.begin()</code>, <code class="code">container.end()</code>,
            and <code class="code">begin</code> and <code class="code">end</code>
            to <code class="code">check</code>, in that order. It is equivalent to
            <code class="code">rbIN_RANGES(container.begin(), container.end(), 
            begin, end, check)</code>.
            See <a href="ar01s14.html#check_ranges" title="Available classes for performing checks on two ranges">the section called &#8220;Available classes for performing checks on two ranges&#8221;</a> for possible choices for
            <code class="code">check</code></p><p>
				<span class="emphasis"><em>Corresponding class:</em></span> none
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id514864"></a>
				<code class="code">rbIN_RANGE_CONTAINER(begin, end, container, check)</code>
			</h4></div></div></div><a class="indexterm" name="id514866"></a><p>This macro checks whether the elements in the range <code class="code">[begin, end)</code>
			and the container fulfill the check, by giving <code class="code">begin</code>, <code class="code">end</code>,
            <code class="code">container.begin()</code> and <code class="code">container.end()</code>
            to <code class="code">check</code>, in that order. It is equivalent to
            <code class="code">rbIN_RANGES(begin, end, container.begin(), container.end(), check)</code>.
            See <a href="ar01s14.html#check_ranges" title="Available classes for performing checks on two ranges">the section called &#8220;Available classes for performing checks on two ranges&#8221;</a> for possible choices for
            <code class="code">check</code></p><p>
				<span class="emphasis"><em>Corresponding class:</em></span> none
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id514922"></a>
				<code class="code">rbIN_CONTAINER_ARRAY(container, array, check)</code>
			</h4></div></div></div><a class="indexterm" name="id514924"></a><p>This macro checks whether the elements in the container and the array fulfill
            the check, by giving <code class="code">container.begin()</code>, <code class="code">container.end()</code>,
            and the begin and end of the array
            to <code class="code">check</code>, in that order. It is equivalent to
            <code class="code">rbIN_RANGES(container.begin(), container.end(), 
            array, array+sizeof(array)/sizeof(array[0]), check)</code>.
            See <a href="ar01s14.html#check_ranges" title="Available classes for performing checks on two ranges">the section called &#8220;Available classes for performing checks on two ranges&#8221;</a> for possible choices for
            <code class="code">check</code></p><p>
				<span class="emphasis"><em>Corresponding class:</em></span> none
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id514968"></a>
				<code class="code">rbIN_ARRAY_CONTAINER(array, container, check)</code>
			</h4></div></div></div><a class="indexterm" name="id514971"></a><p>This macro checks whether the elements in the array and the container fulfill
            the check, by giving the begin and end of the array,
            and <code class="code">container.begin()</code>, <code class="code">container.end()</code>
            to <code class="code">check</code>, in that order. It is equivalent to
            <code class="code">rbIN_RANGES(array, array+sizeof(array)/sizeof(array[0]),
            container.begin(), container.end(), check)</code>.
            See <a href="ar01s14.html#check_ranges" title="Available classes for performing checks on two ranges">the section called &#8220;Available classes for performing checks on two ranges&#8221;</a> for possible choices for
            <code class="code">check</code></p><p>
				<span class="emphasis"><em>Corresponding class:</em></span> none
			</p></div><p>The following 2 macros (that have VALUES in their name) are
			still experimental. They are only available on compilers that support
			C++0X initializer lists. At the moment of writing this works on gcc 4.5, but not with Visual C++.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id515019"></a>
				<code class="code">rbIN_CONTAINER_VALUES(container, il, check)</code>
			</h4></div></div></div><a class="indexterm" name="id515021"></a><p>This macro checks whether the elements in the container and the array fulfill
            the check, by giving <code class="code">container.begin()</code>, <code class="code">container.end()</code>,
            and the begin and end of the array
            to <code class="code">check</code>, in that order. It is equivalent to
            <code class="code">rbIN_RANGES(container.begin(), container.end(), 
            array, array+sizeof(array)/sizeof(array[0]), check)</code>.
            See <a href="ar01s14.html#check_ranges" title="Available classes for performing checks on two ranges">the section called &#8220;Available classes for performing checks on two ranges&#8221;</a> for possible choices for
            <code class="code">check</code></p><p>
				<span class="emphasis"><em>Corresponding class:</em></span> none
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id515066"></a>
				<code class="code">rbIN_VALUES_CONTAINER(il, container, check)</code>
			</h4></div></div></div><a class="indexterm" name="id515068"></a><p>This macro checks whether the elements in the array and the container fulfill
            the check, by giving the begin and end of the array,
            and <code class="code">container.begin()</code>, <code class="code">container.end()</code>
            to <code class="code">check</code>, in that order. It is equivalent to
            <code class="code">rbIN_RANGES(array, array+sizeof(array)/sizeof(array[0]),
            container.begin(), container.end(), check)</code>.
            See <a href="ar01s14.html#check_ranges" title="Available classes for performing checks on two ranges">the section called &#8220;Available classes for performing checks on two ranges&#8221;</a> for possible choices for
            <code class="code">check</code></p><p>
				<span class="emphasis"><em>Corresponding class:</em></span> none
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="equal-pair"></a>
				<code class="code">Checking maps</code>
			</h4></div></div></div><a class="indexterm" name="id515116"></a><p>For maps, the rich boolean functor class <code class="classname">EqualPair</code> can be used,
			which checks if the first and second element of two pairs are both equal.
			E.g. <code class="code">rbIN_CONTAINERS(map1, map2, Compare&lt;&gt;().That(EqualPair()))</code>.</p><p>
				<span class="emphasis"><em>Example output:</em></span>
				</p><pre class="screen">predicate doesn't apply on ranges `map1.begin()'-`map1.end()'
and `map2.begin()'-`map2.end()'
M: keys: {(1) == (1) - ok}, values: {(a) == (a) - ok} - ok
X: keys: {(2) == (2) - ok}, values: {(b) == (q) - nok} - nok
M: keys: {(3) == (3) - ok}, values: {(c) == (c) - ok} - ok</pre><p>
			</p><p>Note: The matching algorithm uses partial matches for this rich boolean, which means that
        two different elements in the range of which either the key or the value is equal, will be matched
        in preference to elements that are totally different</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id515156"></a>Creating an inline container</h3></div></div></div><a class="indexterm" name="id515162"></a><a class="indexterm" name="id515166"></a><p>The function <code class="code">Values</code> takes from one to eight arguments of the same type,
			and returns a container that contains these values. This container can be used in any
			Rich Boolean where a container is expected.
		</p><pre class="programlisting">
  std::vector&lt;int&gt; vec;
  ...
  // check that vec contains the values 2, 4 and 5:
  RB_ASSERT(rbIN_CONTAINERS(RichBool::Values(2, 4, 5), vec, RichBool::AllEqual&lt;&gt;()));
        </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xiterator"></a>Containers with overloaded funtions <code class="code">begin()</code> and <code class="code">end()</code></h3></div></div></div><p>To use the Rich Booleans in this section, include <code class="filename">richbool/xcontainers.hpp</code>.</p><p>Note: the containers that are given to the Rich Booleans that take two containers, can be of different types.
        Even their elements can be of different types, as long as the Rich Boolean functor
        can have them as arguments.</p><p>The Rich Booleans in this section work with every container for which overloaded non-member functions <code class="code">begin</code> and <code class="code">end</code>
        exist that return iterators over the container, and whose elements can be streamed out (see <a href="ar01s12.html" title="Choose your strings">the section called &#8220;Choose your strings&#8221;</a>).
		A method to stream out the whole container not necessary.</p><a class="indexterm" name="id515223"></a><a class="indexterm" name="id515228"></a><p>Defining overloaded functions that return iterators can be done easily
        for the <code class="code">wxArray</code> (whether they are defined with <code class="code">WX_DEFINE_ARRAY</code>
        or with <code class="code">WX_DECLARE_OBJ_ARRAY</code> and <code class="code">WX_DEFINE_OBJ_ARRAY</code>) and <code class="code">wxList</code>
        containers in wxWidgets, with the macros <code class="code">WX_DEFINE_ARRAY_ITERATOR</code> and <code class="code">WX_DEFINE_LIST_ITERATOR</code>,
        that are defined in the file <code class="filename">richbool/wx_iter.hpp</code>.
        </p><p>
			</p><div class="example"><a name="id515267"></a><p class="title"><b>Example 42. Making iterators for a wxArray</b></p><div class="example-contents"><pre class="programlisting">
    #include "richbool/xcontainers.hpp"
    #include "richbool/wx_iter.hpp"

    WX_DECLARE_OBJARRAY(MyClass, MyArray);
    WX_DEFINE_ARRAY_ITERATOR(MyClass, MyArray, MyArrayIterator);
    MyArray arr1, arr2;
    ...
    MOD_ASSERT(rbIN_XCONTAINERS(arr1, arr2, AllEqual&lt;&gt;()));</pre>
        For arrays that contain primitive elements, add a suffix _P to avoid compiler warnings
        about <code class="code">operator-&gt;</code>:
        <pre class="programlisting">
    WX_DEFINE_ARRAY_INT(int, IntArray);
    WX_DEFINE_ARRAY_ITERATOR_P(int, IntArray, IntArrayIterator);
    IntArray arr1, arr2;
    ...
    MOD_ASSERT(rbIN_XCONTAINERS(arr1, arr2, AllEqual&lt;&gt;()));</pre></div></div><p><br class="example-break">
		</p><p>Note that wxWidgets 2.6 added the methods <code class="code">begin</code> and <code class="code">end</code>
        to many of the containers (but not all), so that the equivalent Rich Booleans for STL-like containers can be used.
        For these containers it is easier to use these versions instead of the ones in this section, since
        you don't have to define iterators on them.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id515296"></a>
				<code class="code">rbIN_XCONTAINER(container, check)</code>
			</h4></div></div></div><a class="indexterm" name="id515298"></a><p>This macro checks whether the elements in the container fulfill
            the check, by giving <code class="code">begin(container)</code> and <code class="code">end(container)</code>
            to <code class="code">check</code>. It is equivalent to
            <code class="code">rbIN_RANGE(begin(container), end(container), check)</code>.
            See <a href="ar01s14.html#check_range" title="Available Rich Boolean functor classes for checking a range">the section called &#8220;Available Rich Boolean functor classes for checking a range&#8221;</a> for possible choices for
            <code class="code">check</code></p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">InXContainer&lt;class Algorithm, class GetValue1=Value&gt;</code>
				This class has the following constructors:
				</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">a default constructor</li><li style="list-style-type: disc">a constructor that takes one argument of the type
				        <code class="classname">Algorithm</code></li></ul></div><p>
				If the default constructor is used, the default constructor of
				<code class="classname">Algorithm</code> is called.
				Objects of this template class can also be made with the template function
				<code class="code">template&lt;Algorithm&gt; InXContainer&lt;class Algorithm&gt;
				MakeInXContainer(Algorithm algorithm)</code>.
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id515369"></a>
				<code class="code">rbIN_XCONTAINERS(container1, container2, check)</code>
			</h4></div></div></div><a class="indexterm" name="id515372"></a><p>This macro checks whether the elements in the containers fulfill
            the check, by giving <code class="code">begin(container1)</code>, <code class="code">end(container1)</code>,
            <code class="code">begin(container2)</code> and <code class="code">end(container2)</code>
            to <code class="code">check</code>. It is equivalent to
            <code class="code">rbIN_RANGES(begin(container1), end(container1), 
            begin(container2), end(container2), check)</code>.
            See <a href="ar01s14.html#check_ranges" title="Available classes for performing checks on two ranges">the section called &#8220;Available classes for performing checks on two ranges&#8221;</a> for possible choices for
            <code class="code">check</code></p><p>
				<span class="emphasis"><em>Corresponding class:</em></span>
				<code class="classname">InXContainers&lt;class Algorithm, class GetValue1=Value,
				    class GetValue2=Value&gt;</code>
				This class has the following constructors:
				</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">a default constructor</li><li style="list-style-type: disc">a constructor that takes one argument of the type
				        <code class="classname">Algorithm</code></li></ul></div><p>
				If the default constructor is used, the default constructor of
				<code class="classname">Algorithm</code> is called.
				Objects of this template class can also be made with the template function
				<code class="code">template&lt;Algorithm&gt; InXContainers&lt;class Algorithm&gt;
				MakeInXContainers(Algorithm algorithm)</code>.
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id515450"></a>
				<code class="code">rbIN_XCONTAINER_RANGE(container, begin, end, check)</code>
			</h4></div></div></div><a class="indexterm" name="id515452"></a><p>This macro checks whether the elements in the container and the range
			<code class="code">[begin, end)</code> fulfill
            the check, by giving <code class="code">begin(container)</code>, <code class="code">end(container)</code>,
            and <code class="code">begin</code> and <code class="code">end</code>
            to <code class="code">check</code>, in that order. It is equivalent to
            <code class="code">rbIN_RANGES(begin(container), end(container), 
            begin, end, check)</code>.
            See <a href="ar01s14.html#check_ranges" title="Available classes for performing checks on two ranges">the section called &#8220;Available classes for performing checks on two ranges&#8221;</a> for possible choices for
            <code class="code">check</code></p><p>
				<span class="emphasis"><em>Corresponding class:</em></span> none
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id515507"></a>
				<code class="code">rbIN_RANGE_XCONTAINER(begin, end, container, check)</code>
			</h4></div></div></div><a class="indexterm" name="id515510"></a><p>This macro checks whether the elements in the range <code class="code">[begin, end)</code>
			and the container fulfill the check, by giving <code class="code">begin</code>, <code class="code">end</code>,
            <code class="code">begin(container)</code> and <code class="code">end(container)</code>
            to <code class="code">check</code>, in that order. It is equivalent to
            <code class="code">rbIN_RANGES(begin, end, begin(container), end(container), check)</code>.
            See <a href="ar01s14.html#check_ranges" title="Available classes for performing checks on two ranges">the section called &#8220;Available classes for performing checks on two ranges&#8221;</a> for possible choices for
            <code class="code">check</code></p><p>
				<span class="emphasis"><em>Corresponding class:</em></span> none
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id515565"></a>
				<code class="code">rbIN_XCONTAINER_ARRAY(container, array, check)</code>
			</h4></div></div></div><a class="indexterm" name="id515567"></a><p>This macro checks whether the elements in the container and the array fulfill
            the check, by giving <code class="code">begin(container)</code>, <code class="code">end(container)</code>,
            and the begin and end of the array
            to <code class="code">check</code>. It is equivalent to
            <code class="code">rbIN_RANGES(begin(container), end(container),
            array, array+sizeof(array)/sizeof(array[0]), check)</code>.
            See <a href="ar01s14.html#check_ranges" title="Available classes for performing checks on two ranges">the section called &#8220;Available classes for performing checks on two ranges&#8221;</a> for possible choices for
            <code class="code">check</code></p><p>
				<span class="emphasis"><em>Corresponding class:</em></span> none
			</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id515612"></a>
				<code class="code">rbIN_ARRAY_XCONTAINER(array, container, check)</code>
			</h4></div></div></div><a class="indexterm" name="id515614"></a><p>This macro checks whether the elements in the array and the container fulfill
            the check, by giving the begin and end of the array,
            and <code class="code">begin(container)</code>, <code class="code">end(container)</code>
            to <code class="code">check</code>, in that order. It is equivalent to
            <code class="code">rbIN_RANGES(array, array+sizeof(array)/sizeof(array[0]),
            begin(container), end(container), check)</code>.
            See <a href="ar01s14.html#check_ranges" title="Available classes for performing checks on two ranges">the section called &#8220;Available classes for performing checks on two ranges&#8221;</a> for possible choices for
            <code class="code">check</code></p><p>
				<span class="emphasis"><em>Corresponding class:</em></span> none
			</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id515660"></a>Deprecated Rich Booleans</h3></div></div></div><a class="indexterm" name="id515662"></a><a class="indexterm" name="id515669"></a><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id515678"></a>Working on one range</h4></div></div></div><a class="indexterm" name="id515680"></a><a class="indexterm" name="id515685"></a><a class="indexterm" name="id515690"></a><p><code class="code">rbIN_RANGE_ARG(begin, end, check, arg)</code>, <code class="code">rbIN_CONTAINER_ARG(container, check, arg)</code>
			and <code class="code">rbIN_XCONTAINER_ARG(container, check, arg)</code>.</p><p>These are similar to their counterparts without the suffix <code class="code">_ARG</code>, but
			<code class="code">check</code> is a Rich Boolean functor factory, and <code class="code">arg</code> a Rich Boolean functor
			(that takes one argument), that is given to <code class="code">check</code> to create a Rich Boolean functor
			that performs the check on the range.</p><p><span class="emphasis"><em>Corresponding class:</em></span> none</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id516640"></a>Working on two ranges</h4></div></div></div><a class="indexterm" name="id516642"></a><a class="indexterm" name="id516647"></a><a class="indexterm" name="id516652"></a><a class="indexterm" name="id516656"></a><a class="indexterm" name="id516661"></a><a class="indexterm" name="id516666"></a><p><code class="code">rbIN_RANGES_ARG(begin1, end1, begin2, end2, check, arg)</code>,
			<code class="code">rbIN_RANGE_ARRAY_ARG(begin, end, array, check, arg)</code>,
			<code class="code">rbIN_CONTAINERS_ARG(container1, container2, check, arg)</code>,
			<code class="code">rbIN_CONTAINER_ARRAY_ARG(container, array, check, arg)</code>,
			<code class="code">rbIN_XCONTAINERS_ARG(container1, container2, check, arg)</code> and
			<code class="code">rbIN_XCONTAINER_ARRAY_ARG(container, array, check, arg)</code></p>.
			<p>These are similar to their counterparts without the suffix <code class="code">_ARG</code>, but
			<code class="code">check</code> is a Rich Boolean functor factory, and <code class="code">arg</code> a Rich Boolean functor
			(that takes two arguments), that is given to <code class="code">check</code> to create a Rich Boolean functor
			that performs the check on the two ranges.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s13.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s15.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Known problems </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Using Rich Boolean functors in Rich Boolean macros</td></tr></table></div></body></html>
